---
title: "Extending competitive accessibility for multi-modal analysis"
author: Anastasia Soukhov, Javier Tarriño Ortiz, Julio A. Soria-Lara, Antonio Páez
format: docx
bibliography: bibliography.bib
---
```{r load-packages, include=FALSE, cache=FALSE}
# library(fitdistrplus) # Help to Fit of a Parametric Distribution to Non-Censored or Censored Data
# library(gridExtra) # Miscellaneous Functions for "Grid" Graphics 
# library(kableExtra) # Construct Complex Table with 'kable' and Pipe Syntax

# library(shadowtext) # Shadow Text Grob and Layer
# library(skimr) # Compact and Flexible Summaries of Data
# library(spdep) # Spatial Dependence: Weighting Schemes, Statistics
# library(tidyr) # Tidy Messy Data
# options(scipen = 999)

library(patchwork) # The Composer of Plots
library(sf) # Simple Features for R
library(dplyr) # A Grammar of Data Manipulation
library(ggplot2) # Create Elegant Data Visualisations Using the Grammar of Graphics
library(ggforce) # Accelerating 'ggplot2'
library(geomtextpath) # Curved Text in 'ggplot2'
library(ggpmisc) # Miscellaneous Extensions to 'ggplot2'
library(ggrepel) # Automatically Position Non-Overlapping Text Labels with 'ggplot2'
library(ggspatial) # Spatial Data Framework for ggplot2
library(huxtable) # Easily Create and Style Tables for LaTeX, HTML and Other Formats
library(scales) # Scale Functions for Visualization
```

```{r sp_avail-function,include=FALSE}
#defining the spatial availability function
sp_avail <- function(x, o_id, d_id, pop, opp, r, f, alpha = 1){

  o_id <- rlang::enquo(o_id)
  d_id <- rlang::enquo(d_id)
  pop <- rlang::enquo(pop)
  opp <- rlang::enquo(opp)
  r <- rlang::enquo(r)
  f <- rlang::enquo(f)

  # Sum of population in system
  sum_pop <- x %>%
    dplyr::distinct(!!o_id,
                    .keep_all = TRUE) %>%
    dplyr::mutate(sum_pop = !!r*(!!pop)^alpha) %>%
    dplyr::pull(sum_pop) %>%
    sum()

  # Balancing factor size
  f_p <- dplyr::pull(x, !!r) * dplyr::pull(x, !!pop)^alpha / sum_pop

  # Sum of impedance
  sum_impedance <- x %>%
    dplyr::group_by(!!d_id) %>%
    dplyr::summarize(sum_impedance = sum(!!f))

  # Join sum of impedance to table
  x <- x %>%
    dplyr::left_join(sum_impedance,
                     by = rlang::as_name(d_id))
  
  # Balancing factor impedance
  f_c <- dplyr::pull(x, !!f) / x$sum_impedance

  # Add balancing factors to table
  x$f_c <- f_c
  x$f_p <- f_p
  
  # Sum of balancing factors for mass and impedance
  sum_pa <- x %>%
    dplyr::group_by(!!d_id) %>%
    dplyr::summarize(sum_pa= sum(f_p * f_c))

  x <- x %>%
    dplyr::left_join(sum_pa,
                     by = rlang::as_name(d_id))
  
  # Joint balancing factor
  f_t <- (f_p * f_c) / dplyr::pull(x, sum_pa)

  dplyr::pull(x, !!opp) * f_t
}

#detailed
sp_avail_detailed <- function(x, o_id, d_id, pop, opp, r, f, alpha = 1){
  
  o_id <- rlang::enquo(o_id)
  d_id <- rlang::enquo(d_id)
  pop <- rlang::enquo(pop)
  opp <- rlang::enquo(opp)
  r <- rlang::enquo(r)
  f <- rlang::enquo(f)
  
  sum_pop <- x %>%
    dplyr::distinct(!!o_id,
                    .keep_all = TRUE) %>%
    dplyr::mutate(sum_pop = !!r*(!!pop)^alpha) %>%
    dplyr::pull(sum_pop) %>%
    sum()
  
  f_p <- dplyr::pull(x, !!r) * dplyr::pull(x, !!pop)^alpha / sum_pop
  
  sum_impedance <- x %>%
    dplyr::group_by(!!d_id) %>%
    dplyr::summarize(sum_impedance = sum(!!f))
  
  x <- x %>%
    dplyr::left_join(sum_impedance,
                     by = rlang::as_name(d_id))
  
  f_c <- dplyr::pull(x, !!f) / x$sum_impedance
  
  x$f_c <- f_c
  x$f_p <- f_p
  
  sum_pa <- x %>%
    dplyr::group_by(!!d_id) %>%
    dplyr::summarize(sum_pa= sum(f_p * f_c))
  
  x <- x %>%
    dplyr::left_join(sum_pa,
                     by = rlang::as_name(d_id))
  x$f_t <- (f_p * f_c) / dplyr::pull(x, sum_pa)
  
  x %>%
    dplyr::mutate(V_ij = !!opp * f_t)
}
```

```{r synthetic-data, include=FALSE}
od_tt <- data.frame(i = c("A", "A", "A", "B", "B", "B", "C", "C", "C"), # Three origins
                    j = c("1", "2", "3", "1", "2", "3", "1", "2", "3"), # Three destinations
                    tt_z = c(15, 30, 100, 30, 15, 100, 100, 100, 15), # Travel time, z-mode (original)
                    tt_x = c(10, 25, 80, 25, 10, 80, 80, 80, 10), # Travel time, x-mode (the faster mode - like car)
                    pop = c(50000, 50000, 50000, 150000, 150000, 150000, 10000, 10000, 10000), # Population
                    opp = c(100000, 100000, 10000, 100000, 100000, 10000, 100000, 100000, 10000)) # Jobs

#write the dataframe long.
od_tt_m <- data.frame(i = c("A", "A", "A", "A", "A", "A",
                            "B", "B", "B", "B", "B", "B",
                            "C", "C", "C", "C", "C", "C"), # Three origins
                    j = c("1", "2", "3", "1", "2", "3", 
                          "1", "2", "3", "1", "2", "3", 
                          "1", "2", "3", "1", "2", "3"), # Three destinations
                    m = c("z", "z", "z", "x", "x", "x",
                          "z", "z", "z", "x", "x", "x",
                          "z", "z", "z", "x", "x", "x"),
                    tt = c(15, 30, 100, 10, 25, 80, #travel time, z-mode (original) AND THEN x-mode (the faster mode)
                           30, 15, 100, 25,  10,  80,
                           100, 100, 15, 80, 80, 10), 
                    pop = c(10000, 10000, 10000, 40000, 40000, 40000,
                            50000, 50000,50000, 100000, 100000, 100000,
                            3000, 3000, 3000, 7000,7000, 7000),
                    opp = c(100000, 100000, 10000, 100000, 100000, 10000,
                            100000, 100000, 10000, 100000, 100000, 10000,
                            100000, 100000, 10000, 100000, 100000, 10000)) 
```

```{r data-figure-with-toy-example, include=FALSE}
od <- data.frame(id = c("A", "B", "C", "1", "2", "3"),
                 type = c("Population", "Population", "Population", "Jobs", "Jobs", "Jobs"),
                 size = c(50000, 150000, 10000, 100000, 100000, 10000),
                 x = c(2.5, 2.5, 6.5, 0.5, 0.5, 6.5),
                 y = c(8.0, 2.5, 4.5, 7.5, 2.5, 2.5))

centers <- data.frame(id = c("Urban center", "Suburb", "Satellite town"),
                 radius = rep(1.3, 3),
                 x = c(1.5, 1.5, 6.5),
                 y = c(2.5, 7.5, 3.5))

# od_lines coded as segments
od_lines <- data.frame(x = c(2.5, 2.5, 2.5, 2.5, 2.5, 2.5, 6.5, 6.5, 6.5),
                       y = c(8.0, 8.0, 8.0, 2.5, 2.5, 2.5, 4.5, 4.5, 4.5),
                       xend = c(0.5, 0.5, 6.5, 0.5, 0.5, 6.5, 0.5, 0.5, 6.5),
                       yend = c(7.5, 2.5, 2.5, 7.5, 2.5, 2.5, 7.5, 2.5, 2.5),
                       group = c("A", "A", "A", "B", "B", "B", "C", "C", "C"),
                       time = c("15 min (z)\n10 min (x)", "30 min (z)\n25 min (x)", "100 min (z)\n80 min (x)",
                                "30 min (z)\n25 min (x)", "15 min (z)\n10 min (x)", "100 min (z)\n80 min (x)",
                                "100 min (z)\n80 min (x)", "100 min (z)\n80 min (x)", "15 min (z)\n10 min (x)"))

od_table <- data.frame(Center = c("A", "B", "C", "1", "2", "3"),
  Size = c("50,000 pop", "150,000 pop", "10,000 pop", "100,000 jobs", "100,000 jobs", "10,000 jobs"))
```

```{r, creating-toy-example-plot, eval=FALSE}
toy_example_plot <- ggplot() + 
  # Plot centers
  geom_circle(data = centers,
             aes(x0 = x, 
                 y0 = y,
                 r = radius),
             color = "grey40") +
  annotate(geom = "label", 
           x=c(0.5, 0.6, 7),
           y=c(9, 1, 5.2), 
           label = c("Suburban", "Urban", "Satellite"), 
           size=4, 
           label.size=NA) +
  # Connect origins and destinations with curves
  geom_curve(data = od_lines,
               aes(x = x,
                   y = y,
                   xend = xend,
                   yend = yend,
                   linetype = group,
                   group = group),
             curvature = 0.20,
             linewidth = 1,
             color = "black") +
  # Text on curves
  geom_textcurve(data = od_lines,
               aes(x = x,
                   y = y,
                   xend = xend,
                   yend = yend,
                   linetype = group,
                   group = group,
                   label = time),
             curvature = 0.20,
             color = "black") +
  # Plot origins and destinations
  geom_point(data = od,
            aes(size = size,
                x = x, 
                y = y, 
                color = type,
                shape = type)) +
  scale_size(range = c(4, 10)) +
  # Label origins and destinations
  geom_text(data = od, 
            aes(x, 
                y, 
                label=id), 
            size=3) +
  # Create table
  annotate(geom = "table",
           x = 8, 
           y = 9, 
           label = list(od_table),
           fill = "white",
           size=3) +
  # Theme the plot
  coord_fixed() + 
  theme_void() + guides(shape = "none", size = "none", color = "none", linetype ="none") 

toy_example_plot
ggsave("images/Fig1.png",dpi=600)
```

# Abstract

An increasing number of studies within the domain of transportation planning are concerned with the inequities in accessibility to opportunities. A dimension of these inequities arise from differences in access by mode type (e.g., commuting using a car as opposed to transit). However, methods implemented in current multi-modal accessibility literature are lacking. This paper presents an extension of _spatial availability_, a singly-constrained competitive accessibility measure, for the context of multi-modal accessibility analysis. We first illustrate the features of spatial availability that lend itself to multi-modal analysis. We then demonstrate its use on the case study of Low Emission Zones in Madrid (Spain) and highlight how this policy intervention changes the accessibility of populations using different modes. In summary, spatial availability can be used to create and interpret multi-modal policy intervention scenarios unlike previous methods: this creation and interpretation can help regions envision a more sustainable and equitable access-to-opportunity landscape.

# Introduction

<!-- outlines the use of place-based accessibility measures in the literature: equity, planning -- esp. as it relates to modal competition (brief) -->
Location-based access (or accessibility) measures are ubiquitous in the literature and are present in a variety of configurations. They aim to capture the "potential interaction" that the population at a location has with opportunities based on transportation systems and land-use. Their implementation varies widely depending on the the research question and goal. 

<!-- different types of location-based accessibility measures: constrained vs. unconstrained. Introduce examples of unconstrained measures. -->
From the perspective of representing a score of _opportunities_ that can be accessed by the population at a location, location-based accessibility measures can be categorized as 1) cumulative opportunity measures, 2) weighted cumulative opportunity measures, and 3) competitive accessibility measures as defined in [@levinsonTransportAccessManual2020]. All these types of measures use a distance decay function (otherwise known as an impedance function) to discount the opportunities that can be potentially accessed based on the travel cost for the population. These three types of accessibility measures can be unified into two categories. Cumulative and weighted cumulative opportunity measures are related: in fact, they just have differing impedance functions. The cumulative opportunity measure has a binary impedance function and the weighted cumulative opportunity measure has an impedance function that can take any functional form (e.g, exponential, log-normal, or even any sort of probability density function as discussed in the Trip Length Distribution literature). From another perspective, these measure are also unconstrained. The impedance function that discounted the opportunities is not constrained by any mass effect. In this way, cumulative and weighted cumulative measures can be considered _unconstrained_ accessibility measures.

<!-- examples of constrained (competitive) measures, the introduction of spatial availability -->
The third type of accessibility measure, competitive measures, discount the number of opportunities allocated based on the population that is demanding those opportunities in addition to discounting by travel impedance (like unconstrained accessibility measures). Competitive measures hence consider both the supply of the opportunities and the demand for those opportunities by the population in addition to the travel impedance. They have been criticized for being difficult to compute (relative to unconstrained measures) and difficult to interpret as they are a ratio of supply to demand [@levinsonTransportAccessManual2020]. In @soukhovIntroducingSpatialAvailability2023, we introduce spatial availability, a type of competitive accessibility measure that is _constrained_ beside a popular _unconstrained_ accessibility measure (Hansen-type gravity model) and a competitive accessibility measure (two-step floating catchment area (2SFCA)). We title spatial availability a _constrained_ accessibility measure since it proportionally allocates all the opportunities (supply) to each origin-location based on competition from the population (demand) and travel impedance in a single step with an interpretable output. The output is the number of opportunities available in the region, per location, such that if all the values for the locations in the region were summed they would equal the total opportunities in the region.

ANother example of proportional allocation, BFCA

<!-- policy applications of accessibility broadly, but what's missing is multi-modal accessibility methods -->
The consideration of both supply of opportunities and demand from the population is important for policy applications. Spatial availability can be used to create supply per capita benchmarks for locations, and the delta of supply from this benchmark to existing conditions can be used to motivate policy. Currently, conventional _unconstrained_ accessibility measures are difficult for planners to operationalize for a variety of reasons. Furthermore, exisiting competitive measures are difficult to interpret. 

However, this is a gap in the literature. Researchers and transport planners needs accessibility tools that interpretable consider competition. This is the aim of this paper. We plan to expland to this measure to multi-modal systems. opportunities are avialble to users of different modes. The cost of reaching them is not uniform. 

<!-- An example of a case where conventional accessibility measures (unconstrained and competitive) fall short is in considering multi-modal accessibility. Take for instance, measuring the accessibility to opportunities for a region for car and transit modes. The literature suggests that these modes are in direct competition. A user, if they have access to both modes, will consider the utility (travel impedance) of using one or the other. Thus, the potential for the population to interact with opportunities is directly dependant on ... the opportunities..  -->

<!-- introduction of multi-modal accessibility. when modes compete with one another. at the center of this is that modes SHOULD compete. competition considerations is required.-->


## An introduction to the limitations of multi-modal methods 

<!-- no competition: multi-modal accessibility examples -->
@tahmasbiMultimodalAccessibilitybasedEquity2019 computes accessibility across modes. No competition between modes is considered. Methodologically... 

<!-- with competition but NOT proportional allocation: multimodal accessibility examples-->
@carpentieriMultimodalAccessibilityPrimary2020 "Multimodal Accessibility to Primary Health Services for the Elderly: A Case Study of Naples, Italy"

@taoInvestigatingImpactsPublic2020a "Investigating the impacts of public transport on job accessibility in Shenzhen, China: a multi-modal approach"

@maoMeasuringSpatialAccessibility2013 "Measuring spatial accessibility to healthcare for populations with multiple transportation modes"

A clustering method to modify the cumulative accessibility measure @mohriClusteringMethodMeasuring2021

<!-- summary of the paper-->
With the inconsistencies and limitations of existing measures in mind, we propose the multimodal application of spatial availability. To illustrate this application, in Section 2, we demonstrate the formulation of spatial availability in a simple example of two modes and three population and opportunity centers in a synthetic example. In Section 3, we then demonstrate an empirical example of the low emission zone in Madrid Spain. Specifically, how an expansion in the restriction of private vehicles changes the access to opportunities for transit, cycling and walking. In Section 4, we provide concluding remarks on the strengths of the use of spatial availability as a multimodal accessibility measure, potential future uses in policy planning scenarios, and limitations of accessibility measures. 

# Illustrative example: using spatial availability for multiple modes

In brief, we define the _spatial availability_ at $i$ ($V_{i}$) as the proportion of all opportunities $O$ that are allocated to $i$ from all destinations $j$:
$$
V_i = \sum_{j=1}^J O_jF^t_{ij}
$$

\noindent where:

-   $V_i$ is the number of spatially available opportunities at $i$.
-   $O_j$ is the number of opportunities at $j$.
-   $F^t_{ij}$ is a balancing factor that depends on the demand for opportunities and cost of movement in the system.

The general form of spatial availability is a sum: this is similar to Hansen-type accessibility (popular _unconstrained_ measure) and Shen-type accessibility (popular _competitive_ and _unconstrained_ measure). What makes spatial availability a _constrained_ measure are the balancing factors that allocate opportunities proportionally. The balancing factor $F^t_{ij}$ consists of two components: a population-based balancing factor $F^p_{i}$ and an impedance-based balancing factor $F^c_{ij}$ that, respectively, allocate opportunities to $i$ in proportion to the size of the population of the different competing centers (the mass effect of the gravity model) and the cost of reaching opportunities (the impedance effect). 

```{r, synthetic-example-plot, fig.cap="\\label{fig:Fig1} Modified synthetic example from Shen (1998) with locations of employment centers (in orange), population centers (in blue), number of jobs and population, and travel times for two modes (x mode and z mode).", fig.show='hold', fig.align='center'}
knitr::include_graphics("images/Fig1.png")
```

```{r access-calcs-table, include=FALSE}
#table with all the accessibility calculations
# Impedance parameter
b <- 0.1

# Calculate impedance function
od_tt_m <- od_tt_m %>%
  mutate(f = exp(-b * tt))
```

```{r calculating-beta-0.1-Vi-table-creation}
od_tt_m <- od_tt_m %>%
  mutate(catch = 1) %>%
  sp_avail_detailed(o_id = i, #spatial availability
                    d_id = j, 
                    pop = pop,
                    opp = opp,
                    r = catch,
                    f = f, 
                    alpha = 1)

V_i <- od_tt_m %>%
  group_by(i) %>%
  summarize(V_i = sum(V_ij))

od_tt_m <- od_tt_m %>%
  left_join(V_i, by = "i") %>%
  transmute(i,
            j,
            m,
            pop,
            opp,
            tt,
            V_ij = ifelse(V_ij < 0.001, "< 0.001", round(V_ij, 3)),
            V_i = ifelse(V_i < 0.001, "< 0.001", round(V_i, 3)),
            f = ifelse(f < 0.001, "< 0.001", round(f, 3)),
            f_p = ifelse(f_p < 0.001, "< 0.001", round(f_p, 3)),
            f_c = ifelse(f_c < 0.001, "< 0.001", round(f_c, 3)),
            f_t = ifelse(f_t < 0.001, "< 0.001", round(f_t, 3)))
```

```{r merging-data-for-table}
colnames(od_tt_m) <- c("i", "j","Mode", "Pop.", "Opp.", "TT", "V", "V_i", 
                       "f(TT)", "F^p", "F^c", "F^t")

od_tt_m_hux <- od_tt_m %>%
  as_hux()
```

```{r toy-example-table-all-values, cache=FALSE}
table_toy  <- od_tt_m_hux %>%
  set_background_color(everywhere, 7, "grey90") %>%
  set_background_color(everywhere, 8, "lightyellow") %>%
  set_bold(1, everywhere) %>%
  set_bold(everywhere, 1) %>%
  # set_bottom_border(c(1,2,5,10,15,20), everywhere) %>%
  # set_right_border(everywhere, c(1,4,7,10), brdr(1, "solid", "grey")) %>%
  # set_align(1:20, 1, "left") %>%
  # set_align(1:20,  2:10, "center") %>%
  # set_number_format(c(6,10,11:15,16:18), everywhere, 3) %>% #the smaller numbers, have 3 decimals
  # set_number_format(c(7:9,19,20), everywhere, 1) %>% # the larger numbers, have 1 decimal
  merge_cells(2:7, 1) %>% merge_cells(8:13, 1) %>% merge_cells(14:19, 1) %>%
  merge_cells(14:15, 2) %>% merge_cells(16:17, 2) %>% merge_cells(18:19, 2) %>% 
  merge_cells(2:4, 3) %>% merge_cells(5:7, 3) %>% merge_cells(8:10, 3) %>% 
  merge_cells(11:13, 3) %>% merge_cells(14:16, 3) %>% merge_cells(17:19, 3) %>% 
  merge_cells(2:4, 4) %>% merge_cells(5:7, 4) %>% merge_cells(8:10, 4) %>% 
  merge_cells(11:13, 4) %>% merge_cells(14:16, 4) %>% merge_cells(17:19, 4) %>% 
  merge_cells(2:7, 5) %>% merge_cells(8:13, 5) %>% merge_cells(14:19, 5) %>%
  merge_cells(2:7, 8) %>% merge_cells(8:13, 8) %>% merge_cells(14:19, 8) %>%
  set_caption("Summary description of the synthetic example: Spatial availability at each origin per mode $V_{im}$ (grey) and at each origin $V_i$ (yellow)") %>%
  set_label("tab:synthetic-example") %>% 
  set_latex_float("h!") %>% 
  set_width(1.1)

font_size(table_toy) <- 7

table_toy[1:19,]
```

We adapt the illustrative example used in @shen1998 assuming two modes and demonstrate spatial availability's within this multi-modal application. See the Figure \ref{fig:Fig1} and the Table \ref{tab:synthetic-example} with calculated spatial availability values (yellow - per origin and mode, and grey per origin). We use a negative exponential impedance function with $\beta=0.1$ as also used in @shen1998: we assume this impedance function for both modes.
$$
f(c_{ij}) = \exp(-\beta\cdot c_{ij})
$$

## Proportional allocation by population

According to the gravity modelling framework, the potential for interaction depends on the mass (i.e., the population) and the friction of distance (i.e., the impedance function). We begin by describing the proposed proportional allocation mechanism based on demand by the population. Recall, the total population in the example is 210,000. The proportion of the population by population center, by the two modes ($x$, and $z$) is:
$$
\begin{array}{l}
F^{pm}_{i} = \frac{P_{i}^m}{\sum_{m=1}^M\sum_{i=1}^N P_{i}^m}\\

F^{pm}_A = \frac{50,000}{210,000} & \text{where } F^{px}_A = \frac{40,000}{210,000} \text{ & } F^{pz}_A = \frac{10,000}{210,000}\\ 
\\
F^{pm}_B = \frac{150,000}{210,000} & \text{where } F^{px}_B = \frac{100,000}{210,000} \text{ & } F^{pz}_B = \frac{50,000}{210,000}\\
\\
F^{pm}_C = \frac{10,000}{210,000} & \text{where } F^{px}_C = \frac{7,000}{210,000} \text{ & } F^{pz}_C = \frac{3,000}{210,000}\\
\end{array}
$$

Jobs are allocated proportionally from each employment center to each population center depending on their population sizes as per the balancing factors $F^p_i$. In this way, employment center 1 allocates $100,000\cdot \frac{50,000}{210,000}= 23,809.52$ jobs to $A$ (the suburb). Similarly, employment centers 2 and 3 allocate $100,000\cdot \frac{150,000}{210,000}= 71,428.57$ jobs to $B$ (the urban city) and $100,000\cdot \frac{10,000}{210,000}= 7,142.857$ jobs to $C$ (the satellite city). Notice how this mechanism ensures that the total number of jobs at employment center 1 is preserved at 100,000. The jobs at the employment centers are allocated proportional to the population size of the population center relative to all the population center sizes. Larger population centers are more competitive (i.e., they demand more) than smaller population centers, so they get allocated more job opportunities. 

However, how do the populations access these jobs? In this synthetic example, the population either uses the regular mode $z$ or uses the faster mode $x$. Their choice in mode is already assigned: the mode selected can be seen as a characteristic of the population, or a way to subset the total population. In this way, the introduction of this population-characteristic of mode selection adds another layer of competition to the mass effect. We demonstrated that employment center 1 allocates $23,809.52$ jobs to $A$ but 20% of these jobs are allocated to population using $z$ ($10,000$ of the $50,000$ population in $A$) and 80% is allocated to the population using the faster mode $x$ ($40,000$ of the $50,000$ population in $A$). Similarly, employment centers 2 and 3 allocate $71,428.57$ jobs to $B$ (the urban city) of which 66% are allocated to the population using $z$ and 33% to the population using $x$ mode and the $7,142.857$ jobs allocated to $C$ (the satellite city) is split between 30% of the population using mode $z$ and 70% of the population using mode $x$.

Considering the subsets of the population that use the two different modes, the total number of jobs that are assigned to each population center and then to each sub-set of population, is still preserved. The total sum of all the jobs allocated in the region is still 210,000 in our example.

We can verify that the number of jobs allocated is consistent with the total number of jobs in the system:
$$
\begin{array}{l}
\text{Employment center 1 to population centers A, B, and C: }\\
100,000 \cdot \frac{40,000}{210,000} + 100,000 \cdot \frac{10,000}{210,000} + 100,000 \cdot \frac{100,000}{210,000} + 100,000 \cdot \frac{50,000}{210,000} + 100,000 \cdot \frac{7,000}{210,000} + 100,000 \cdot \frac{3,000}{210,000} = 100,000\\
\\
\text{Employment center 2 to population centers A, B, and C: }\\
100,000 \cdot \frac{40,000}{210,000} + 100,000 \cdot \frac{10,000}{210,000} + 100,000 \cdot \frac{100,000}{210,000} + 100,000 \cdot \frac{50,000}{210,000} + 100,000 \cdot \frac{7,000}{210,000} + 100,000 \cdot \frac{3,000}{210,000} = 100,000\\
\\
\text{Employment center 3 to population centers A, B, and C: }\\
10,000 \cdot \frac{40,000}{210,000} + 10,000 \cdot \frac{10,000}{210,000} + 10,000 \cdot \frac{100,000}{210,000} + 10,000 \cdot \frac{50,000}{210,000} + 10,000 \cdot \frac{7,000}{210,000} + 10,000 \cdot \frac{3,000}{210,000} = 10,000\\
\end{array}
$$

In the general case where there are $N$ population centers in the region, we define the following population-based balancing factors in Equation (\ref{eq:population-balancing-factor}):
```{=tex}
\begin{equation}
\label{eq:population-balancing-factor}
F^{pm}_{i} = \frac{P_{i}^m}{\sum_{m=1}^M\sum_{i=1}^N P_{i}^m}
\end{equation}
```

Balancing factor $F^p_{i}$ corresponds to the proportion of the population in origin $i$ relative to the population in the region. On the right hand side of the equation, the numerator $P_{i}^m$ is the population at origin $i$ that use each type of mode $m$ for the full set of modes $M$. 

The discussion so far concerns only the mass effect (i.e., population size) of the gravity model. In addition, the potential for interaction with opportunities is thought to increase with decreasing cost, so next we define similar balancing factors but based on the impedance.

## Proportional allocation by cost

Clearly, exclusively using the population balancing factor $F^{pm}_{i}$ to calculate spatial availability does not account for the cost of reaching employment centers. Consider instead a set of balancing factors $F^{cm}_{ij}$ that accounts for the friction of distance. For this example, we define an impedance function $f(c_{ij}^m)$ that equals $\exp(-\beta\cdot c_{ij}^m)$ where $\beta = 0.1$ and the travel time $c_{ij}^m$ is either 15, 30 or 100 minutes for $m=z$ or 10, 20, or 80 minutes for $m=x$. 

To illustrate, the impedance-based balancing factors $F^{cm}_{ij}$ would be the following for employment center 1 (employment center 2 and 3 have their own balancing factor values for each origin $i$ as is discussed later):
$$
\begin{array}{l}
F_{ij}^{cm} = \frac{f(c_{ij}^m)}{\sum_{m=1}^M \sum_{i=1}^N f(c_{ij}^m)}\\

F^{cx}_{A1} = \frac{0.223130}{0.223130 + 0.049787 + 0.000045 + 0.3678794 + 0.1353353 + 0.0003354626} = 0.287349 \\
F^{cx}_{B1} = \frac{0.049787}{0.223130 + 0.049787 + 0.000045 + 0.3678794 + 0.1353353 + 0.0003354626} = 0.06411619\\
F^{cx}_{C1} = \frac{0.000045}{0.223130 + 0.049787 + 0.000045 + 0.3678794 + 0.1353353 + 0.0003354626} = 0.00005795144\\

F^{cz}_{A1} = \frac{0.3678794}{0.223130 + 0.049787 + 0.000045 + 0.3678794 + 0.1353353 + 0.0003354626} = 0.4737587\\
F^{cz}_{B1} = \frac{0.1353353}{0.223130 + 0.049787 + 0.000045 + 0.3678794 + 0.1353353 + 0.0003354626} = 0.1742861\\
F^{cz}_{C1} = \frac{0.0003354626}{0.223130 + 0.049787 + 0.000045 + 0.3678794 + 0.1353353 + 0.0003354626} = 0.000432012\\
\end{array}
$$

Balancing factors $F^{cm}_{ij}$ use the impedance function to proportionally allocate more jobs to closer population centers, that is, to those with populations _more willing to reach the jobs_. Indeed, the factors $F^{cm}_{ij}$ can be thought of as the proportion of the population at $i$ willing to travel to destination $j$, conditional on the travel behavior as given by the impedance function. For instance, ${28.7349}\%$ of jobs from employment center 1 are allocated to population $A$ using the slower mode $x$ and ${47.37587}\%$ of the jobs are allocated to the population using the faster mode $z$ based on impedance. Population center $A$ is assigned $47.37587\%+{28.7349}\% = 76.11077\%$ of the jobs in the region based on the impedance, but it can be seen that the population using the faster mode is assigned a larger proportion of jobs. The population that uses the faster mode $z$ is more competitive than the population that uses the slower mode $x$.

So as follows from our example, of the 100,000 jobs at employment center 1 the number of jobs allocated to population center $A$ is $100,000\times 0.7611077 = 76,110.77$ jobs - $28,734.9$ to population using mode $x$ and $47,375.87$ to population using mode $z$. The number allocated to population center $B$ is $100,000\times 0.2384023= 23,840.23$ jobs - $6,411.619$ to population using mode $x$ and $17,428.61$ to population using mode $z$; and the number allocated to population center $C$ is $100,000\times 0.0004899634 = 48.99634$ jobs - $5.795144$ to population using mode $x$ and $43.2012$ to population using mode $z$. We see once more that the total number of jobs at the employment center is preserved at $100,000$. The proportional allocation mechanism assigns the largest share of jobs to population center $A$, which is the closest to employment center 1 and the smallest to the more distant population center $C$. Additionally, the sum of the population using the faster mode $z$ across all three population centers gets assigned the majority of jobs from employment center $1$ ($64.81028\%$).
<!-- NOTE: what's interesting is that when considering multiple modes employment center (1) allocates less jobs to urban (A), more jobs to suburban (B) and more jobs to remote (c). Why is this interesting? The suburban and sat. centers have f(c_ij) from 20, 30, 80, 100 min -- higher average values than just considering 30 and 100 min (as in the single mode example) hence relatively favouring the impedance of the inter-city commute than the intercity commute (10 and 15 min). The addition of a faster mode at the inter-city commutes reweighs the modal options and makes this form of travel more competitive, overall. -->

In the general case where there are $N$ population centers in the region, we define the following impedance-based balancing factors for each $i$ $j$ flow for each $m$:
```{=tex}
\begin{equation}
\label{eq:impedance-balancing-factor}
F_{ij}^{cm} = \frac{f(c_{ij}^m)}{\sum_{m=1}^M \sum_{i=1}^N f(c_{ij}^m)}\\
\end{equation}
```

## Assembling mass and impedance effects

Population and the cost of travel are both part of the gravity modelling framework. Since the balancing factors defined in the preceding sections are proportions, they can be combined multiplicatively to obtain their joint effect. This multiplicative relationship can alternatively be understood as the joint probability of allocating opportunities and is captured by Equation (\ref{eq:balancing-factors}), where $F^{pm}_{i}$ is the population-based balancing factor that grants a larger share of the existing opportunities to the subsets of populations using mode $m$ located at population centers $i$. $F^{cm}_{ij}$ is the impedance-based balancing factor that grants a larger share of the existing opportunities to subsets of populations using $m$ mode in population centers $i$ with the least costly travel impedance from $i$ to $j$. Considering both the mass effect from population and weighting travel flows based on impedance is in line with the tradition of gravity modeling. Equation (\ref{eq:population-balancing-factor}) defines this combined balancing factor. As we demonstrate in this section, within spatial availability, we can consider modes $m$ as a subset of the population in the region. In doing so, makes population centers $i$ with larger subsets of populations more attractive (have a larger mass effect) and makes the subset of populations using least costly modes $m$ more attractive with respect to proportional allocation of opportunities in the region.

```{=tex}
\begin{equation}
\label{eq:balancing-factors}
F^{tm}_{ij} = \frac{F^{pm}_{i} \cdot F^{cm}_{ij}}{\sum_{m=1}^M \sum_{i=1}^N F^{pm}_{i} \cdot F^{cm}_{ij}}
\end{equation}
```

\noindent with $F^{pm}_{i}$ and $F^{cm}_{ij}$ as defined in Equations (\ref{eq:population-balancing-factor}) and (\ref{eq:impedance-balancing-factor}) respectively. The combined balancing factor $F^{tm}_{ij}$ is used to proportionally allocate jobs from $j$ to $i$ based mass-effect and impedance-effect of populations using multiple modes $m$. Hence, spatial availability with consideration for multiple modes $m$ is given by Equation (\ref{eq:spatial-availability}).

```{=tex}
\begin{equation}
\label{eq:spatial-availability}
V^m_{i} = \sum_{j=1}^J O_j\ F^{tm}_{ij}\\

V_{i} = \sum_{m=1}^M V^m_{i}\\
\end{equation}
```

The terms in Equation (\ref{eq:spatial-availability}):

-   $F^{tm}_{ij}$ is a balancing factor as defined in Equation (\ref{eq:balancing-factors}).
-   $m$ is a set of modes used by populations in the region $m = 1, \cdots, M$.
-   $i$ is a set of origin locations in the region $i = 1,\cdots, N$.
-   $j$ is a set of destination locations in the region $j = 1,\cdots,J$.
-   $O_j$ is the number of opportunities at location $j$.
-   $V^m_{i}$ is the spatial availability at $i$ for mode $m$.
-   $V_{i}$ is the spatial availability at $i$.

<!-- NOTE: do we want to display this by mode,origin or origin or both? -->

We calculate $V^m_{i}$ for each population center $i$ and mode $m$ and then present the spatial availability $V_{i}$ per population center in Table \ref{tab:synthetic-example}.

Notice, the population enters the calculation of $V^m_{i}$ through $F^{pm}_i$. Returning to the example in Figure \ref{fig:Fig1}, Table \ref{tab:synthetic-example} also contains the information needed to calculate $V_i$, with $\beta$ set again to 0.1. Column __V_ij__ are the jobs available to each origin from each employment center. In this column $V_{A1}=$ $68,648.305$ is the number of jobs available at $A$ from employment center 1. Column __V_i__ (i.e., $\sum_{m=1}^M \sum_{j=1}^J V_{ijm}$) gives the total number of jobs available to origin $i$ from each subset of the population using modes $m$. We can verify that the total number of jobs available is consistent with the total number of jobs in the region (with some small rounding error):
$$
\sum_{i=A} V_{ijm} = 8070.736 + 962.474 + 1.378 + 53225.576 + 6347.407 + 40.733 = 68648.305\\
\sum_{i=B} V_{ijm} =9004.123 + 21567.552 + 6.891 + 29690.578 + 71117.764 + 101.833 = 131488.741\\
\sum_{i=C} V_{ijm} =0.493 + 0.263 + 2032.006 + 8.494 + 4.540 + 7817.159 = 9862.955\\

\sum_{i=1}^N V_{ijm} = (68648.305) + (131488.741) + (9862.955) = 210000 
$$
Table \ref{tab:synthetic-example} and the equations above display the intuition in the spatial availability calculation for the synthetic example. Population center $A$ has greater job availability due to: 1) its close proximity to employment center 1; combined with 2) less competition (i.e., a majority of the population have to travel longer distances to reach employment center 1). Job availability is lower for population center $B$ due to much higher competition (150,000 people can reach 100,000 jobs at equal cost). And center $C$ has almost as many jobs available as it has population. 

Further, we can also examine the competition between modes. The potential population using the slower mode $z$ is `r od_tt_m %>% group_by(i,Mode) %>% summarize(pop = first(Pop.), .groups = "drop") %>% filter(Mode == "z") %>% dplyr::select(pop) %>% sum()` (`r ((od_tt_m %>% group_by(i,Mode) %>% summarize(pop = first(Pop.), .groups = "drop") %>% filter(Mode == "z") %>% dplyr::select(pop) %>% sum()) / (od_tt_m %>% group_by(i,Mode) %>% summarize(pop = first(Pop.), .groups = "drop") %>% dplyr::select(pop) %>% sum())) %>% percent()` of the potential population in the region). Despite this, this slower mode $z$ accounts for only `r ((od_tt_m %>% group_by(i,Mode) %>% summarize(V = sum(V), .groups = "drop") %>% filter(Mode == "z") %>% dplyr::select(V) %>% sum()) / (od_tt_m %>% group_by(i,V) %>% summarize(V = sum(V), .groups = "drop") %>% dplyr::select(V) %>% sum())) %>% percent()` of the region's spatial availability in the region - the rest is allocated to the population using faster mode $x$ (of which represents `r ((od_tt_m %>% group_by(i,Mode) %>% summarize(pop = first(Pop.), .groups = "drop") %>% filter(Mode == "x") %>% dplyr::select(pop) %>% sum()) / (od_tt_m %>% group_by(i,Mode) %>% summarize(pop = first(Pop.), .groups = "drop") %>% dplyr::select(pop) %>% sum())) %>% percent()` of the population). This comparison between the slower mode $z$ and the other mode $x$ is detailed as follows:

Potential population $P$ using mode $z$ and $x$ to go to $j$:
$$
\sum_{m}^M P_{im} = 210000 \text{ total population}\\

\sum_{m=z} P_{im} = 10000 + 50000 + 3000 = 63000\\
\sum_{m=x} P_{im} =  40000 + 100000 + 7000 = 147000\\
$$

Spatial availability $V$ for mode $z$ and $x$:
$$
\sum_{m}^M V_{ijm} = 210000 \text{ total jobs}\\

\sum_{m=z} V_{ijm} = 8070.736 + 962.474 + 1.378 + 9004.123 + 21567.552 + 6.891 + 0.493 + 0.263 + 2032.006  = 41645.92\\
\sum_{m=x} V_{ijm} =  53225.576 + 6347.407 + 40.733 + 29690.578 + 71117.764 + 101.833 + 8.494 + 4.540 + 7817.159 = 168354.1\\
$$

Noteably, the population that uses the slower mode $x$ is allocated 10% less spatial availability: this means that the population using the faster mode $z$ captures 10% _more_ spatially availability opportunities than the proportion of it's population metered by distance decay demands. This exposes an issue of inequality. 

This can be explored through travel times. The population using the slower mode $z$ only captures 20% of the spatial availability, but accounts for `r ((od_tt_m %>% group_by(i,Mode) %>% summarize(V_tt = sum(V*TT), .groups = "drop") %>% filter(Mode == "z") %>% dplyr::select(V_tt) %>% sum()) / (od_tt_m %>% group_by(i,Mode) %>% summarize(V_tt = sum(V*TT), .groups = "drop") %>% dplyr::select(V_tt) %>% sum())) %>% percent()` of the potential travel time traveled in the region: 6% more travel time than the spatial available opportunities. 

Alternatively, this can be explored through proportional benchmarks. As the number of opportunities are preserved through the region and within the sub-populations, a spatial availability per capita as presented in Equation (\ref{eq:SA-per-capita}) is defined at each population center, mode, and/or regionally:
```{=tex}
\begin{equation}
\label{eq:SA-per-capita}
v_{im} = \frac{V_{im}}{P_{im}}
\end{equation}
```

The spatial availability per capita values for $A$, $B$, and $C$ are 1.37, 0.877 and 0.986, respectively. For the faster mode $x$, the benchmarks are evidently higher than the averages at: 1.49, 1.01, and 1.12 respectively. Starkly lower, especially for $B$ and $C$ are the slower mode $z$ with values of: 0.903, 0.612, and 0.678. See as follows:

Potential travel time associated with $V_{ijm}$:
$$
\sum_{m}^M V_{ijm} tt_{ijm} = 3,009,957 \text{ minutes}\\

\sum_{m=z} V_{ijm} tt_{ijm} = 774,954 \text{ minutes}\\
\sum_{m=x}  V_{ijm} tt_{ijm} =  2,235,003 \text { minutes}\\
$$

Per capita spatial availability $v_{ijm}$, notice how the slower mode $z$ has much lower per capita values than the faster mode $x$ and is lower than the region total benchmarks:
```{r}
#use the following to calculate first, the regional averages, and then the origin mode specific (z and then x).
#od_tt_m %>% group_by(i) %>% summarize(v = first(V_i)/sum(unique(Pop.)), .groups = "drop")
#od_tt_m %>% group_by(i,Mode) %>% summarize(v = sum(V/Pop.), .groups = "drop") %>% filter(Mode == "z")
#od_tt_m %>% group_by(i,Mode) %>% summarize(v = sum(V/Pop.), .groups = "drop") %>% filter(Mode == "x")
```

$$
\sum_{m}^M \sum_{i=A} \frac{V_{ijm}}{P_{im}}  = 1.37 \text{ sa jobs per capita}\\
\sum_{m}^M \sum_{i=B} \frac{V_{ijm}}{P_{im}}  = 0.877 \text{ sa jobs per capita}\\
\sum_{m}^M \sum_{i=C} \frac{V_{ijm}}{P_{im}}  = 0.986 \text{ sa jobs per capita}\\

\sum_{m=z} \sum_{i=A} \frac{V_{ijm}}{P_{im}}  = 0.903 \text{ sa jobs per capita}\\
\sum_{m=z} \sum_{i=B} \frac{V_{ijm}}{P_{im}}  = 0.612 \text{ sa jobs per capita}\\
\sum_{m=z} \sum_{i=C} \frac{V_{ijm}}{P_{im}}  = 0.678 \text{ sa jobs per capita}\\

\sum_{m=x} \sum_{i=A} \frac{V_{ijm}}{P_{im}}  = 1.49 \text{ sa jobs per capita}\\
\sum_{m=x} \sum_{i=B} \frac{V_{ijm}}{P_{im}}  = 1.01 \text{ sa jobs per capita}\\
\sum_{m=x} \sum_{i=C} \frac{V_{ijm}}{P_{im}}  = 1.12 \text{ sa jobs per capita}\\
$$
As a third way of interpreting spatial availability, spatial availability per capita can be related to the spatial mismatch theory. Opportunities should be equal to demand. In this way, values below 1 are particularly troubling from the perspective of equity.

# The case of Madrid's low emission zones: multimodal accessibility landscapes

## Case study background
<!-- a summary about low emission zones, they are a geographic accessibility restriction. they change the accessibility landscape-->

## Data 
```{r load-data}
load("data-prep/data/zn1259.RData") 
zn1259 <- zn %>% dplyr::select(c("FID", "CD_ZT12", "ZT1259"))
remove(zn)
load("data-prep/data/zn208.RData")
load("data-prep/data/zn_u.RData") # a key to join the zn1259 to the zn208 + contains municipality names

zn1259 <-  merge(zn1259, zn_u, by="ZT1259")

LEZ_centro <- read_sf("data-prep/data-raw/LEZ.shp") %>% st_transform(4326) %>% mutate(merge_all = 1) %>%
    group_by(merge_all) %>%
    summarise(geometry = sf::st_union(geometry)) %>%
    ungroup()
#add M30 for visualizing
LEZ_M30 <- read_sf("data-prep/data-raw/Zona_Bajas_Emisiones_MADRID.shp") %>% st_transform(4326)

#creating a list of zones that correspond to the zn208, which indicate if they are in a LEZ.
LEZ_centro_list <- st_intersection(zn208, LEZ_centro) %>% 
  st_drop_geometry() %>% 
  dplyr::select(CD_ZT208) %>% 
  unlist()

LEZ_M30_list <- st_intersection(zn208, LEZ_M30) %>% 
  st_drop_geometry() %>% 
  dplyr::select(CD_ZT208) %>% 
  unlist()

#import travel times
load("./data-prep/data-raw/intermed/ttresults/output_OD_bike.Rdata")
load("./data-prep/data-raw/intermed/ttresults/output_OD_car.Rdata")
load("./data-prep/data-raw/intermed/ttresults/output_OD_transit.Rdata")
load("./data-prep/data-raw/intermed/ttresults/output_OD_walk.Rdata")
```

```{r travel-data-from-survey}
#import travel survey 2018
load(file = "data-prep/data/OD_v.RData")

#Keep only the direct home to work trips for the spatial availability calculation (no chained home-to-x-to-work trips, they only make up a small portion of home-to-work trips anyways, see the exploration of this in the 'data-exploration.rmd' file)
OD_v_HW <- OD_v %>% filter(VORI == "1" & VDES == "2" &
                             VORI_Municipality == "Madrid" & VDES_Municipality == "Madrid" &
                             TIEMPO_VIAJES <= 120) #VORG = 1 = casa, VDES = 2 = trabajo

#here we separate all the "car" trips, "transit" trips, "bike" trips, and "walk" trips. We then will create 4 different impedance functions
transit_HW_alltt <- OD_v_HW  %>% 
  filter(MODO_PRIORITARIO <= 9) %>% #(1. Renfe Cercanías ', 2. Autobus interurbano, 3. Autobus urbano otro municipio, 4. Metro, 5. Metro ligero/tranvía, 6. Autobus urbano Madrid EMT, 7. Resto renfe, 8. Autobus discrecional, 9. Autobus de largo recorrido)
  transmute(TIEMPO_VIAJES, 
            ELE_G_POND_ESC2,
            mode = "transit")

car_motor_HW_alltt <- OD_v_HW  %>% 
  filter(MODO_PRIORITARIO <= 19 & MODO_PRIORITARIO >= 10) %>% #includes both motorcycles and cars (specifically: 10. Taxi, 11. Coche conductor particular, 12. Coche conductor empresa, 13. Coche conductor alquiler sin conductor, 14. Coche pasajero particular, 15. Coche pasajero empresa, 16. Coche pasajero alquiler con conductor, 17. Moto/ciclomotor particular, 18. Moto/ciclomotor publica, 19. Moto/ciclomotor empresa)
  transmute(TIEMPO_VIAJES, 
            ELE_G_POND_ESC2,
            mode = "car/motor")

bike_HW_alltt <- OD_v_HW  %>% 
  filter(MODO_PRIORITARIO <= 23 & MODO_PRIORITARIO >= 20) %>% #includes cycling and 'otros', specificially: 20. Bicicleta particular, 21. Bicicleta publica, 22. Bicicleta empresa, 23. Otros)
  transmute(TIEMPO_VIAJES, 
            ELE_G_POND_ESC2,
            mode = "bike")

walk_HW_alltt <- OD_v_HW  %>% filter(MODO_PRIORITARIO == 24) %>% #"24. Andando/pie"
  transmute(TIEMPO_VIAJES,
            ELE_G_POND_ESC2,
            mode = "walk")
```


```{r fitting-impedance-function1}
#see which curve could fit the best using the descdist() function 

#transit
transit_HW_alltt_long <- transit_HW_alltt[rep(seq_len(dim(transit_HW_alltt %>% dplyr::select(-mode))[1]), transit_HW_alltt$ELE_G_POND_ESC2), 1]
fitdistrplus::descdist(data=transit_HW_alltt_long) #try beta, uniform, and normal

#car
car_motor_HW_alltt_long <- car_motor_HW_alltt[rep(seq_len(dim(car_motor_HW_alltt %>% dplyr::select(-mode))[1]), car_motor_HW_alltt$ELE_G_POND_ESC2), 1]
fitdistrplus::descdist(data=car_motor_HW_alltt_long) #try beta, gamma

#bike
bike_HW_alltt_long <- bike_HW_alltt[rep(seq_len(dim(bike_HW_alltt %>% dplyr::select(-mode))[1]), bike_HW_alltt$ELE_G_POND_ESC2), 1]
fitdistrplus::descdist(data=bike_HW_alltt_long) #try beta, gamma

#walk
walk_HW_alltt_long <- walk_HW_alltt[rep(seq_len(dim(walk_HW_alltt %>% dplyr::select(-mode))[1]), walk_HW_alltt$ELE_G_POND_ESC2), 1]
fitdistrplus::descdist(data=walk_HW_alltt_long) #try beta, gamma, exp

```


```{r fitting-impedance-function2-transit}
# using fitdist function to fit a distribution using the default maximum likelihood estimation method and Nelder-Mead method for direct optimization

#for transit, try: uniform, normal, gamma, lognormal
gamma_ <- fitdistrplus::fitdist(data=transit_HW_alltt$TIEMPO_VIAJES,
                                "gamma", 
                                method="mle",
                                weights = round(transit_HW_alltt$ELE_G_POND_ESC2),
                                optim.method="Nelder-Mead")
unif_ <- fitdistrplus::fitdist(data=transit_HW_alltt$TIEMPO_VIAJES,
                                "unif", 
                                method="mle",
                                weights = round(transit_HW_alltt$ELE_G_POND_ESC2),
                               optim.method="Nelder-Mead")
norm_ <- fitdistrplus::fitdist(data=transit_HW_alltt$TIEMPO_VIAJES,
                                "norm", 
                                method="mle",
                                weights = round(transit_HW_alltt$ELE_G_POND_ESC2),
                                optim.method="Nelder-Mead")
lnorm_ <- fitdistrplus::fitdist(data=transit_HW_alltt$TIEMPO_VIAJES,
                                "lnorm", 
                                method="mle",
                                weights = round(transit_HW_alltt$ELE_G_POND_ESC2),
                                optim.method="Nelder-Mead")

gamma_$aic #lowest aic and bic, so we pick this distribution.
unif_$aic 
norm_$aic
lnorm_$aic

gamma_$bic #lowest aic and bic, so we pick this distribution.
unif_$bic 
norm_$bic
lnorm_$bic

HW_transit_gamma <- gamma_
```
```{r fitting-impedance-function2-car}
#for car, try: uniform, lnorm
gamma_ <- fitdistrplus::fitdist(data=car_motor_HW_alltt$TIEMPO_VIAJES,
                                "gamma", 
                                method="mle",
                                weights = round(car_motor_HW_alltt$ELE_G_POND_ESC2),
                                optim.method="Nelder-Mead")

lnorm_ <- fitdistrplus::fitdist(data=car_motor_HW_alltt$TIEMPO_VIAJES,
                                "lnorm", 
                                method="mle",
                                weights = round(car_motor_HW_alltt$ELE_G_POND_ESC2),
                                optim.method="Nelder-Mead")

gamma_$aic #lowest aic and bic, so we pick this distribution.
lnorm_$aic

gamma_$bic #lowest aic and bic, so we pick this distribution.
lnorm_$bic

HW_car_motor_gamma <- gamma_
```
```{r fitting-impedance-function2-bike}
#for bike, try: uniform, lnorm
gamma_ <- fitdistrplus::fitdist(data=bike_HW_alltt$TIEMPO_VIAJES,
                                "gamma", 
                                method="mle",
                                weights = round(bike_HW_alltt$ELE_G_POND_ESC2),
                                optim.method="Nelder-Mead")

lnorm_ <- fitdistrplus::fitdist(data=bike_HW_alltt$TIEMPO_VIAJES,
                                "lnorm", 
                                method="mle",
                                weights = round(bike_HW_alltt$ELE_G_POND_ESC2),
                                optim.method="Nelder-Mead")

gamma_$aic 
lnorm_$aic #lowest aic and bic, so we pick this distribution.

gamma_$bic 
lnorm_$bic #lowest aic and bic, so we pick this distribution.

HW_bike_lnorm <- lnorm_
```

```{r fitting-impedance-function2-walk}
#for walk, try: uniform, lnorm, normal
gamma_ <- fitdistrplus::fitdist(data=walk_HW_alltt$TIEMPO_VIAJES,
                                "gamma", 
                                method="mle",
                                weights = round(walk_HW_alltt$ELE_G_POND_ESC2),
                                optim.method="Nelder-Mead")

lnorm_ <- fitdistrplus::fitdist(data=walk_HW_alltt$TIEMPO_VIAJES,
                                "lnorm", 
                                method="mme",
                                weights = round(walk_HW_alltt$ELE_G_POND_ESC2),
                                optim.method="Nelder-Mead")
norm_ <- fitdistrplus::fitdist(data=walk_HW_alltt$TIEMPO_VIAJES,
                                "norm", 
                                method="mle",
                                weights = round(walk_HW_alltt$ELE_G_POND_ESC2),
                                optim.method="Nelder-Mead")

gamma_$aic 
lnorm_$aic #lowest aic and bic, so we pick this distribution.
norm_$aic

gamma_$bic 
lnorm_$bic #lowest aic and bic, so we pick this distribution.
norm_$bic

HW_walk_lnorm <- lnorm_

```

To visualize the impedance functions we create a data frame and calculate the density of the distribution given the estimated parameters:
```{r}
x <- data.frame(t = seq(1, 120, 1))

x_transit <- x %>%
  mutate(f = dgamma(t,
                    HW_transit_gamma$estimate[1],
                    HW_transit_gamma$estimate[2]),
         mode = "transit")

x_car_motor <- x %>%
  mutate(f = dgamma(t,
                    shape = HW_car_motor_gamma$estimate[1],
                    rate = HW_car_motor_gamma$estimate[2]),
         mode = "car/motor")

x_bike <- x %>%
  mutate(f = dlnorm(t,
                    HW_bike_lnorm$estimate[1],
                    HW_bike_lnorm$estimate[2]),
         mode = "bike")

x_walk <- x %>%
  mutate(f = dlnorm(t,
                    HW_walk_lnorm$estimate[1],
                    HW_walk_lnorm$estimate[2]),
         mode = "walk")
```

Bind the empirical and theoretical trip length distributions:
```{r}
tld_empirical <- rbind(transit_HW_alltt,
      car_motor_HW_alltt,
      bike_HW_alltt,
      walk_HW_alltt) %>%
  mutate(mode = factor(mode,
                       levels = c("bike", "walk", "car/motor", "transit")),
         distribution = "empirical") 

tld_theoretical <- rbind(x_transit,
      x_car_motor,
      x_bike,
      x_walk) %>%
  mutate(mode = factor(mode,
                       levels = c("bike", "walk", "car/motor", "transit")))
```

Plot:
```{r}
ggplot() + 
  geom_histogram(data = tld_empirical,
                 aes(x = TIEMPO_VIAJES, 
                     weights = ELE_G_POND_ESC2, 
                     after_stat(density)),
                 bins = 20) +
  geom_line(data = tld_theoretical,
            aes(x = t, y = f)) + 
  facet_wrap(~ mode, nrow = 2)

#here, let's double check the empirical trip length distributions, as we can see from the two generated plots, our input TLD is correct!
rbind(transit_HW_alltt,
      car_motor_HW_alltt,
      bike_HW_alltt,
      walk_HW_alltt) %>%
  mutate(mode = factor(mode,
                       levels = c("bike", "walk", "car/motor", "transit"))) %>%
  ggplot(aes(x = TIEMPO_VIAJES, after_stat(density),
             weights = ELE_G_POND_ESC2
             )) + 
  geom_histogram(bins = 20) + 
  facet_wrap(~ mode, nrow = 2)
```

```{r define-population-balancing-factor}
# We define $P_i$ (for the population balancing factor) for each mode and $O_j$ associated with each zone. To do this, we add the number of trips (by mode) and create objects that contain the number of workers (origin) and jobs (destinations) - by mode:

# Instead of creating various columns like above, create a single column with the mode
OD_v_HW <- OD_v_HW  %>% 
  mutate(mode = case_when(MODO_PRIORITARIO <= 9 ~ "transit",
                          MODO_PRIORITARIO <= 19 & MODO_PRIORITARIO >= 10 ~ "car/motor",
                          MODO_PRIORITARIO <= 23 & MODO_PRIORITARIO >= 20 ~ "bike",
                          MODO_PRIORITARIO == 24 ~ "walk"),
         mode = factor(mode,
                       levels = c("bike", "walk", "car/motor", "transit")))

# The workers are classified by mode and origin. Ex. from Origin 1 five people use bike mode to get to destinations. This is P_i for each m
workers <- OD_v_HW %>%
  group_by(VORIZT1259,
           mode) %>%
  summarize(workers = n(), #we should be summing the number of workers by the weight but we don't have a weight... so for now, 1 row = 1 trip. 
            .groups = "drop")%>%
  rename(ZT1259 = VORIZT1259)

# Calculate the number of jobs per j ($O_j$)
jobs <- OD_v_HW %>%
  group_by(VDESZT1259) %>%
  summarize(jobs = n(),
            .groups = "drop") %>%
  rename(ZT1259 = VDESZT1259)
```

Next join the number of workers summed at each origin to the ZN simple features object:
```{r}
workers_sf <- workers %>%
  # Join workers
  left_join(zn1259,
            by = "ZT1259") %>%
  st_as_sf()

jobs_sf <- jobs %>%
  # Join jobs
  left_join(zn1259,
            by = "ZT1259") %>%
  st_as_sf()
```

Now we reshape the data. Each row will represent an any origin to to 1 destination (i.e., destination row is unique). We will average the travel times, by mode, and then use this average travel time to find the 'f' (impedance value for travel for each mode). Hint: this is why we needed to find the impedance function in the first place! The functions represent the cost of travel for each mode based on the travel time for a trip, since we are averaging together the travel time for each mode.
```{r}
OD <- OD_v_HW %>%
  group_by(VORIZT1259,
           VDESZT1259,
           mode) %>%
  summarize(tt = mean(TIEMPO_VIAJES),
            .groups = "drop")

# Check the mean and median travel times by mode
OD %>% 
  group_by(mode) %>% 
  summarize(mean_tt = mean(tt),
            median_tt = median(tt),
            min_tt = min(tt),
            max_tt = max(tt))
```

Join workers and jobs to OD table:
```{r}
OD_2 <- OD %>%
  left_join(workers,
            by = c("VORIZT1259" = "ZT1259", "mode"))

OD_2 <- OD_2 %>%
  left_join(jobs,
            by = c("VDESZT1259" = "ZT1259"))

#THIS IS TOO MANY!
```

Preview the table for one origin and one destination, as an example:
```{r}
# OD_2 %>% filter(VORIZT1259 == "079-09-225" & VDESZT1259 == 2) #explanation: 'workers' corresponds to the people who leave ORI 1 to go to any destination by mode (P_im) (e.g., 5 workers leave ORI 1 by bike to go to a job somewhere in the region). 'jobs' corresponds to the number of workers that come to DES 2 as a job destination in the region (sum_m O_j). 'tt' corresponds to the average travel time for i to j per mode (avg. c_ijm) (e.g., only 1 trip is made by bike from ORI 1 to DES 2 and it is 5 mins, so the average travel time is 5 mins) -- this c_ijm will be used to calculate f(c_ijm). 
```

Estimate f value using these averaged travel times:
```{r, echo=FALSE, warning=FALSE, message=FALSE}
OD_2 <- OD_2 %>%
  mutate(f = case_when(mode == "transit" ~ dgamma(tt,
                                                  HW_transit_gamma$estimate["shape"], 
                                                  HW_transit_gamma$estimate["rate"]),
                       mode == "car/motor" ~ dgamma(tt,
                                                    HW_car_motor_gamma$estimate["shape"],
                                                    HW_car_motor_gamma$estimate["rate"]),
                       mode == "bike" ~ dlnorm(tt,
                                               HW_bike_lnorm$estimate["meanlog"],
                                               HW_bike_lnorm$estimate["sdlog"]),
                       mode == "walk" ~ dlnorm(tt, 
                                               HW_walk_lnorm$estimate["location"], 
                                               HW_walk_lnorm$estimate["scale"])))
```

## Calculating spatial availability 
Calculate spatial availability:
```{r}
OD_SA <- OD_2 %>%
  mutate(catch = 1) %>%
  mutate(SA_ij = sp_avail(., 
                          o_id = VORIZT1259,
                          d_id = VDESZT1259,
                          pop = workers,
                          opp = jobs,
                          r = catch,
                          f = f))
```

Check that the totals are maintained, it is!:
```{r}
sum(OD_SA$SA_ij, na.rm = T)
sum(jobs$jobs)
#sum(OD_SA$tt)
```
Spatial availability by mode, we can see that car mode captures 71% of the spatial availability but only accounts for XXXX of the tt_ijm !!:
```{r}
OD_SA %>%
  group_by(mode) %>%
  summarize(V_m = sum(SA_ij),
            V_m_perc = sum(SA_ij)/27795,
            tt_m = sum(tt)/780315.1)
```

Okay, let's preform a few more checks and then aggregate spatial availability by origin (zn208) and by origin,mode.

Spatial availability by origin (with check). Here we represent spatial availability per origin across all modes for each i. We know that car mode represents the majority of spatial availability per i overall:
```{r}
SA_i <- OD_SA %>%
  group_by(VORIZT1259) %>%
  summarize(V_i = sum(SA_ij))

summary(SA_i) 
sum(SA_i$V_i)
```

But we can suspect that the spatial distribution of SA is uneven depending on the mode. So here we represent Spatial availability by origin, mode (with check):
```{r}
SA_im <- OD_SA %>%
  group_by(VORI_CD_ZT208, 
           mode) %>%
  summarize(V_im = sum(SA_ij),
            .groups = "drop")

summary(SA_im)
sum(SA_im$V_im)
```

Let's preform some more checks. Calculate worker population by zone of origin:
```{r}
population <- workers %>%
  group_by(CD_ZT208) %>%
  summarize(population = sum(workers))

sum(population$population)
```

Finally, let's join the zonal worker population to the SA_i and SA_im spatial objects (with checks):
```{r}
SA_i <- SA_i %>%
  left_join(population,
            by = c("VORI_CD_ZT208" = "CD_ZT208"))
sum(SA_i$V_i)

SA_im <- SA_im %>%
  left_join(population,
            by = c("VORI_CD_ZT208" = "CD_ZT208"))
sum(SA_im$V_im)
```

To facilitate the interpretation of spatial availability, here we calculate spatial availability per capita:
```{r}
SA_i <- SA_i %>%
  mutate(v_i = V_i/population)

summary(SA_i)

SA_im <- SA_im %>%
  mutate(v_im = V_im/population)

summary(SA_im)
```

Lastly, join geometry of zones to SA so we can visualize:
```{r}
SA_i <- SA_i %>%
  left_join(zn208 %>%
              dplyr::select(CD_ZT208),
            by =c("VORI_CD_ZT208" = "CD_ZT208")) %>%
  st_as_sf()

SA_im <- SA_im %>%
  left_join(zn208 %>%
              dplyr::select(CD_ZT208),
            by = c("VORI_CD_ZT208" = "CD_ZT208")) %>%
  st_as_sf()
```

## Plotting:

Figure out which CD_ZT208 correspond to Madrid - we see that CD_ZT208 1 through 59 do so.
```{r}
t <- zn_u %>% dplyr::select(CD_ZT208, Municipality) %>% group_by(CD_ZT208,Municipality) %>% summarize() %>% filter(Municipality == "Madrid")
t
```

```{r create-bounding-boxes}
zn208 <- zn208 %>% mutate(MM = ifelse(str_starts(ZT208,"Madrid"), 1, 0)) %>% filter(MM == 1)

#create the bounding box for the Toronto region + a little extra
bbox_new1 <- st_bbox(zn208 %>%filter(MM == 1)) # current bounding box

xrange <- bbox_new1$xmax - bbox_new1$xmin # range of x values
yrange <- bbox_new1$ymax - bbox_new1$ymin # range of y values

bbox_new1[1] <- bbox_new1[1] - (0.0 * xrange) # xmin - left
bbox_new1[3] <- bbox_new1[3] + (0.0 * xrange) # xmax - right
bbox_new1[2] <- bbox_new1[2] - (0.0 * yrange) # ymin - bottom
bbox_new1[4] <- bbox_new1[4] + (0.0 * yrange) # ymax - top

bbox_Madrid_muni <- bbox_new1 %>%  # take the bounding box ...
  st_as_sfc()

sf::sf_use_s2(FALSE) #this terns off the spherical geometry component in the st_union() function - this assumes the sf is just planar. Thats' fine for our purposes
Madrid_muni_border <- zn208 %>%
  filter(MM == 1) %>%
  st_union()
```

Plot V (spatial availability) by origin:
```{r}
ggplot() +
  geom_sf(data = SA_i,
          aes(fill = V_i),
          color = NA) +
  scale_fill_distiller(palette = "YlGn", #legend scale bar
                       name = expression(v["i"]),
                       na.value = "grey90",
                       direction = 1,
                       #trans = "log",
                       #breaks=c(0, 10, 100, 1000, 10000)
                       )+
  geom_sf(data = Madrid_muni_border, # border for Madrid muni
          colour=alpha("black",1), 
          size = 0.5, 
          fill=NA, 
          show.legend = "polygon") +
  geom_sf(data = LEZ_centro, 
          colour=alpha("red",1), 
          size = 0.5, 
          fill = NA) + 
  geom_sf(data = LEZ_M30, 
          colour=alpha("cyan",1), 
          size = 0.5, 
          fill = NA) +
  annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
                         height = unit(0.8, "cm"), 
                         width = unit(0.8, "cm"),
                         style = north_arrow_orienteering(line_width = 0.25,
                                                          line_col = "dimgrey", 
                                                          fill = c("white","dimgrey"))) +
  annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
                   height = unit(0.15, "cm")) +
  theme_void() +
  theme(legend.position = c(1.10, 0.25), 
        plot.margin = margin(t = 0, r = 0, b = 0, l = -80)) # positing legend and clipping out white space
```


<!-- Two scenarios: -->
<!-- - 2018: the small low emission zone -->
<!-- - Applying an optimistic restriction: what if we increased the restrictions?  -->

