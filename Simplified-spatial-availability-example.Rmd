---
title: "Simplified-spatial-availability-example"
output: html_document
---

```{r load-packages, include=FALSE, cache=FALSE}
library(tidyverse)
library(sf)
library(fitdistrplus)
library(ggplot2)
library(readxl) #imports excel files
library(patchwork)
library(cowplot)
library(ggspatial)
```

```{r sp_avail-function,include=FALSE}
#defining the spatial availability function
sp_avail <- function(x, o_id, d_id, pop, opp, r, f, alpha = 1){
  
  o_id <- rlang::enquo(o_id)
  d_id <- rlang::enquo(d_id)
  pop <- rlang::enquo(pop)
  opp <- rlang::enquo(opp)
  r <- rlang::enquo(r)
  f <- rlang::enquo(f)
  
  sum_pop <- x %>%
    dplyr::distinct(!!o_id,
                    .keep_all = TRUE) %>%
    dplyr::mutate(sum_pop = !!r*(!!pop)^alpha) %>%
    dplyr::pull(sum_pop) %>%
    sum()
  
  f_p <- dplyr::pull(x, !!r) * dplyr::pull(x, !!pop)^alpha / sum_pop
  
  sum_impedance <- x %>%
    dplyr::group_by(!!d_id) %>%
    dplyr::summarize(sum_impedance = sum(!!f))
  
  x <- x %>%
    dplyr::left_join(sum_impedance,
                     by = rlang::as_name(d_id))
  
  f_c <- dplyr::pull(x, !!f) / x$sum_impedance
  
  x$f_c <- f_c
  x$f_p <- f_p
  
  sum_pa <- x %>%
    dplyr::group_by(!!d_id) %>%
    dplyr::summarize(sum_pa= sum(f_p * f_c))
  
  x <- x %>%
    dplyr::left_join(sum_pa,
                     by = rlang::as_name(d_id))
  f_t <- (f_p * f_c) / dplyr::pull(x, sum_pa)
  
  dplyr::pull(x, !!opp) * f_t
}
```

Import the trip data:
```{r data-import-filter}
load(file = "data/OD_v.RData")
```

Keep only the direct home to work trips:
```{r}
# not chained home to work trips - direct
OD_v_HW <- OD_v %>% filter(VORI == "1" & VDES == "2") #only filter in origin casa trips and destination trabajo
```

Import zones:
```{r}
#importing zones
load("data/zn1259.RData")
load("data/zn208.RData")
load("data/zn_u.RData") # a key to join the zt1259 to the zn208 + contains municipality names
```

# A) Exploring chained-trips... should we include them?

This needs to be re-thought for the ZT208 resolution. Since we don't have an issue with missing data from ZT208 zones, we will skip trying to include chained trips (including also complicates the impedance zone):
<!-- Checking the trip data - it appears each OD is a row, i.e., chained trips are multiple rows. We want to extract every home origin (VORI = 1) to every work destination (VDEST =2) trip as a single row... so let's do this in multiple steps.

Next, let's identify the chained trips and then consolidate them. We only care about trip O/D, travel mode, travel time, and 
```{r}
temp <- OD_v %>% group_by(ID_HOGAR,ID_IND) %>% 
  filter((VORI == "1" & VDES != "2" & VDES != "1") | (VDES == "2" & VORI != "1"& VORI != "2")) %>% #here the origin NEEDS to be from home, the destination can be anywhere OR the origin can be from anywhere but the destination NEEDS to be work. 
  mutate(chained = lag(VDES) - VORI)

chained2 <- (ifelse(temp$chained[-1]==0 | temp$chained==0, 0, NA)) %>% as.data.frame() #identifying chained trips using '0's

temp <- cbind(temp,chained2) %>% dplyr::rename("chained2" = ".")

temp <- temp %>% filter(chained2==0) # filtering only CHAINED trips - reminder these consider only 1 location before work. 1,629 trips 
```

Now... let's only include chained trips with the same mode! 
```{r}
t <- temp %>% group_by(ID_HOGAR, ID_IND) %>% mutate(trip = ifelse(((ID_VIAJE - lag(ID_VIAJE)) == 1)
                                                               & ((MODO_PRIORITARIO - lag(MODO_PRIORITARIO))== 0), 
                                                               MODO_PRIORITARIO, 0)) #if trip is chained the mode (number) is printed, if the trip is not chained a '0' is printed

t %>% filter(trip == 0) %>% nrow() / t  %>% filter(chained == 0) %>% nrow()    #of chained trips / number of non-chained trips
t  %>% filter(trip != 0 & !is.na(trip))%>% nrow() / t %>% filter(chained == 0) %>% nrow() #of chained trips / number of non-chained trips
```
so ~4% of trips are chained, and ~27% of chained trips are not made using the same mode. THe rest of them are (`r temp %>% filter(trip != 0 & !is.na(trip)) %>% nrow() ` trips are chained (1 intermediate destination) and use the same mode).

So my question is... should we include these 1,371 extra chained trips (this is if we consolidate these 2 mini trips into 1 home to work trip (with an intermediate stop)). This only represent ~5% additional trips to the direct home to work 27K trips. If we include them... how do we count travel time? just sum both steps of the trip together..? Is that a good idea..? I don't think so.

Let's see if this sample increases the number of ZTs spatially:
```{r}
#bind the t object (chained) to the workers object. 
t <- t %>% filter(is.na(chained)) # only including origins
t <- t[,1:24] 
OD_v_HW_chained <- rbind(OD_v_HW, t)
```


```{r}
Otrips_zona_c <- OD_v_HW_chained %>% group_by(VORI_CD_ZT208)  %>% summarise(Otrips = (n())) # we group by the origin ZT208 ID and then we summarize the number of rows that have the same ZT using the summarize() function and the n() function to create a new 'Otrips' column.

zn_c <- zn208 %>% merge(Otrips_zona_c, by.x = "CD_ZT208", by.y="VORI_CD_ZT208", all.x = TRUE)

ggplot() +
  geom_sf(data = zn_c,
          aes(fill = Otrips),
          color  = NA) +
  scale_fill_distiller(palette = "Spectral")

Otrips_zona <- OD_v_HW %>% group_by(VORI_CD_ZT208)  %>% summarise(Otrips = (n())) # we group by the origin ZT208 ID and then we summarize the number of rows that have the same ZT using the summarize() function and the n() function to create a new 'Otrips' column.

zn_noc <- zn208 %>% merge(Otrips_zona, by.x = "CD_ZT208", by.y="VORI_CD_ZT208", all.x = TRUE)

ggplot() +
  geom_sf(data = zn_noc,
          aes(fill = Otrips),
          color  = NA) +
  scale_fill_distiller(palette = "Spectral")
```

```{r}
summary(zn_noc$Otrips)
summary(zn_c$Otrips)
```

so as we can see... the number of origin ZNs with NO origin trips doesn't go down - we only have 1 missing ZT using the 208 zonig system and 1 is still missing after including the chained trips. 

Next step... let's try to see what is happening in these NA zones. What sort of origin trips are being generated? (analysis for the 1259 zoning system)-->

<!-- ```{r} -->
<!-- missing_workers <- zn_noc %>% filter(is.na(Otrips)) %>% dplyr::select(ZT1259) #344 zonas are missing home to work trips. -->

<!-- missing_workers <- missing_workers %>% merge(OD_v, by.x = "ZT1259", by.y="VORIZT1259", all.x = TRUE) -->

<!-- temp <- missing_workers %>% st_drop_geometry() %>% group_by(ZT1259) %>% summarise(trip_count = n(), -->
<!--                                                                                   Owork_perc = sum(VORI == 2)/n(), -->
<!--                                                                                   Ostudy_perc = sum(VORI == 4)/n(), -->
<!--                                                                                   Osportwalk_perc = sum(VORI == 10)/n(), -->
<!--                                                                                   Oshop_perc = sum(VORI == 5)/n(), -->
<!--                                                                                   Ohome_perc = sum(VORI == 1)/n()) -->
<!-- temp -->
<!-- ``` -->
<!-- ```{r} -->
<!-- summary(temp) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- # write.csv(missing_workers %>% st_drop_geometry(),"ZT_Trips_missingworkers.csv", row.names = FALSE) -->
<!-- ``` -->

<!-- ‘trip count’ is how many trips there are in each ZT. ‘Owork_perc’ is an origin work purpose (of that trip) in each ZT, i.e. 39.47% of origin trips are work related averaged across all ZTs. ‘Ostudy_perc’ is for study origin trips.. etc. You can see that the majority of origin trip purposes are work. This means that these are predominately ‘work’ related areas and none of the households surveyed live in those ZTs.  -->

<!-- And looking in excel. even if we consider all origin zones from work themed chained trips (i.e., home to somewhere to work) as 'residential locations' (this is incorrect) we STILL have ~170 zones with no work-to-home trips.  -->

# B) Calculating spatial availability - an exploration of 3 approaches

For simplicity. Let's assume we are only considering home to work direct trips. Let's now manually calculate spatial availability $V_{ij}$. (where i is each origin (home) and j is each destination (work))

$$
V_{ij} = O_j\frac{F^p_{ij} \cdot F^c_{ij}}{\sum_{i=1}^K F^p_{ij} \cdot F^c_{ij}}
$$
The population allocation factor is based on _worker population_ for each ij trip $F^p_{ij}$. No function is needed here, we are just going to work with the proportions. 

Also simple - $O_{j}$ - represents the number of jobs at a destination $j$.

The complexity we have for this case study is the travel cost allocation factor $F^c_{ij}$ due to the 4 modes.

Think of $F^c_{ij}$ as the travel cost for each ij trip. This travel cost is based on the fitted impedance function which is calculated for each mode (for our sample, log-normal is selected for all modes other then car - car is gamma). These impedance functions are predicted using each travel time for each mode (i.e., 4 modes, so we have 4 impedance functions). The impedance functions will be used to predict the _mode relative_ cost of travel, specifically, the higher the value, the stronger the travel-time decay effect on spatial availability will be. 

Ultimately, for each origin to destination, the product of $F^c_{ij}$ and $F^p_{ij}$ is divided by the SUM of all $F^c_{ij}$ and $F^p_{ij}$ in that region $K$ (all the origins $i$ that travel to a destination $j$).

We must manipulate the data before we can fit the impedance function:
```{r data-for-impedance}
#here we separate all the "car" trips, "transit" trips, "bike" trips, and "walk" trips. We then will create 4 different imepedance function....
transit_HW_alltt <- OD_v_HW  %>% 
  filter(MODO_PRIORITARIO <= 9) %>%
  #dplyr::select(TIEMPO_VIAJES, ELE_G_POND_ESC2)
  transmute(TIEMPO_VIAJES, 
            ELE_G_POND_ESC2,
            mode = "transit")

car_motor_HW_alltt <- OD_v_HW  %>% 
  filter(MODO_PRIORITARIO <= 19 & MODO_PRIORITARIO >= 10) %>%
  #dplyr::select(TIEMPO_VIAJES, ELE_G_POND_ESC2) #includes both motorcycles and cars
  transmute(TIEMPO_VIAJES, 
            ELE_G_POND_ESC2,
            mode = "car/motor")

bike_HW_alltt <- OD_v_HW  %>% 
  filter(MODO_PRIORITARIO <= 23 & MODO_PRIORITARIO >= 20) %>%
  #dplyr::select(TIEMPO_VIAJES, ELE_G_POND_ESC2)
  transmute(TIEMPO_VIAJES, 
            ELE_G_POND_ESC2,
            mode = "bike")

walk_HW_alltt <- OD_v_HW  %>% filter(MODO_PRIORITARIO == 24) %>%
  #dplyr::select(TIEMPO_VIAJES, ELE_G_POND_ESC2)
  transmute(TIEMPO_VIAJES, 
            ELE_G_POND_ESC2,
            mode = "walk")
```

Then create the impedance functions:
```{r fitting-impedance-function}
# using fitdist function to fit a distribution using the default maximum likelihood estimation method and Nelder-Mead method for direct optimization
lnorm_ <- fitdistrplus::fitdist(data=transit_HW_alltt$TIEMPO_VIAJES,#%>% unlist() %>% as.numeric(),
                                "gamma", 
                                method="mle",
                                #Notice the use of the weights,
                                weights = round(transit_HW_alltt$ELE_G_POND_ESC2),
                                optim.method="Nelder-Mead")
HW_transit_lnorm <- lnorm_

gamma_ <- fitdistrplus::fitdist(data=car_motor_HW_alltt$TIEMPO_VIAJES, #%>% unlist() %>% as.numeric(),
                                "gamma", 
                                method="mle",
                                #Notice the use of the weights,
                                weights = round(car_motor_HW_alltt$ELE_G_POND_ESC2), 
                                optim.method="Nelder-Mead")
HW_car_motor_gamma <- gamma_

lnorm_ <- fitdistrplus::fitdist(data=bike_HW_alltt$TIEMPO_VIAJES, #%>% unlist() %>% as.numeric(),
                                "lnorm", 
                                method="mle",
                                #Notice the use of the weights,
                                weights = round(bike_HW_alltt$ELE_G_POND_ESC2),
                                optim.method="Nelder-Mead")
HW_bike_lnorm <- lnorm_

logis_ <- fitdistrplus::fitdist(data=walk_HW_alltt$TIEMPO_VIAJES, #%>% unlist() %>% as.numeric(),
                                "logis", 
                                method="mle",
                                #Notice the use of the weights,
                                weights = round(walk_HW_alltt$ELE_G_POND_ESC2),
                                optim.method="Nelder-Mead")
HW_walk_lnorm <- logis_
```

To visualize the impedance functions we create a data frame and calculate the density of the distribution given the estimated parameters:
```{r}
x <- data.frame(t = seq(1, 300, 1))

x_transit <- x %>%
  mutate(f = dgamma(t,
                    HW_transit_lnorm$estimate[1],
                    HW_transit_lnorm$estimate[2]),
         mode = "transit")

x_car_motor <- x %>%
  mutate(f = dgamma(t,
                    shape = HW_car_motor_gamma$estimate[1],
                    rate = HW_car_motor_gamma$estimate[2]),
         mode = "car/motor")

x_bike <- x %>%
  mutate(f = dlnorm(t,
                    HW_bike_lnorm$estimate[1],
                    HW_bike_lnorm$estimate[2]),
         mode = "bike")

x_walk <- x %>%
  mutate(f = dlogis(t,
                    HW_walk_lnorm$estimate[1],
                    HW_walk_lnorm$estimate[2]),
         mode = "walk")
```

Bind the empirical and theoretical trip length distributions:
```{r}
tld_empirical <- rbind(transit_HW_alltt,
      car_motor_HW_alltt,
      bike_HW_alltt,
      walk_HW_alltt) %>%
  mutate(mode = factor(mode,
                       levels = c("bike", "walk", "car/motor", "transit")),
         distribution = "empirical") 

tld_theoretical <- rbind(x_transit,
      x_car_motor,
      x_bike,
      x_walk) %>%
  mutate(mode = factor(mode,
                       levels = c("bike", "walk", "car/motor", "transit")))
```

Plot:
```{r}
ggplot() + 
  geom_histogram(data = tld_empirical,
                 aes(x = TIEMPO_VIAJES, 
                     #weights = ELE_G_POND_ESC2, 
                     after_stat(density)),
                 bins = 45) +
  geom_line(data = tld_theoretical,
            aes(x = t, y = f)) + 
  facet_wrap(~ mode, nrow = 2)
```

Double check the empirical trip length distributions:
```{r}
rbind(transit_HW_alltt,
      car_motor_HW_alltt,
      bike_HW_alltt,
      walk_HW_alltt) %>%
  mutate(mode = factor(mode,
                       levels = c("bike", "walk", "car/motor", "transit"))) %>%
  ggplot(aes(x = TIEMPO_VIAJES, weights = ELE_G_POND_ESC2, after_stat(density))) + 
  geom_histogram(bins = 45) + 
  facet_wrap(~ mode, nrow = 2)
```

Then we add the number of trips (by mode) and create objects which contain the number of workers (origin) and jobs (destinations) - by mode:
```{r}
# OD_v_HW <- OD_v_HW  %>% 
#   mutate(trips_transit = ifelse(MODO_PRIORITARIO <= 9, 1,0),
#          trips_car_motor = ifelse(MODO_PRIORITARIO <= 19 & MODO_PRIORITARIO >= 10, 1, 0),
#          trips_bike = ifelse(MODO_PRIORITARIO <= 23 & MODO_PRIORITARIO >= 20, 1, 0),
#          trips_walk = ifelse(MODO_PRIORITARIO == 24, 1, 0))

# Instead of creating various columns like above, create a single column with the mode
OD_v_HW <- OD_v_HW  %>% 
  mutate(mode = case_when(MODO_PRIORITARIO <= 9 ~ "transit",
                          MODO_PRIORITARIO <= 19 & MODO_PRIORITARIO >= 10 ~ "car/motor",
                          MODO_PRIORITARIO <= 23 & MODO_PRIORITARIO >= 20 ~ "bike",
                          MODO_PRIORITARIO == 24 ~ "walk"),
         mode = factor(mode,
                       levels = c("bike", "walk", "car/motor", "transit")))

# workers <- OD_v_HW %>%
#   group_by(VORIZT1259) %>%
#   summarize(workers_transit = sum(trips_transit),
#             workers_car = sum(trips_car_motor),
#             workers_bike = sum(trips_bike),
#             workers_walk = sum(trips_walk),
#             .groups = "drop") %>%
#   transmute(ZT1259 = VORIZT1259,
#             workers_transit,
#             workers_car,
#             workers_bike,
#             workers_walk)

# The workers are classified by mode
workers <- OD_v_HW %>%
  group_by(VORI_CD_ZT208,
           mode) %>%
  # The sum is of the weighted workers
  summarize(workers = sum(ELE_G_POND_ESC2),
            .groups = "drop") %>%
  rename(CD_ZT208 = VORI_CD_ZT208)

# jobs <- OD_v_HW %>%
#   group_by(VDESZT1259) %>%
#   summarize(jobs_transit = sum(trips_transit),
#             jobs_car = sum(trips_car_motor),
#             jobs_bike = sum(trips_bike),
#             jobs_walk = sum(trips_walk),
#             .groups = "drop") %>%
#   transmute(ZT1259 = VDESZT1259,
#             jobs_transit,
#             jobs_car,
#             jobs_bike,
#             jobs_walk)

# Do we need to classify the jobs by mode?
jobs <- OD_v_HW %>%
  group_by(VDES_CD_ZT208) %>%
  summarize(jobs = sum(ELE_G_POND_ESC2),
            .groups = "drop") %>%
  rename(CD_ZT208 = VDES_CD_ZT208)
```

Next join workers and jobs to the ZN simple features object:
```{r}
# zn <- zn %>%
#   # Join workers
#   left_join(workers,
#             by = "ZT1259") %>%
#   # Join jobs
#   left_join(jobs,
#             by = "ZT1259") %>%
#   # Replace NAs with zeros
#   mutate(workers_transit = tidyr::replace_na(workers_transit, 0),
#          workers_car = tidyr::replace_na(workers_car, 0),
#          workers_bike = tidyr::replace_na(workers_bike, 0),
#          workers_walk = tidyr::replace_na(workers_walk, 0),
#          jobs_transit = tidyr::replace_na(jobs_transit, 0),
#          jobs_car = tidyr::replace_na(jobs_car, 0),
#          jobs_bike = tidyr::replace_na(jobs_bike, 0),
#          jobs_walk = tidyr::replace_na(jobs_walk, 0))

workers_sf <- workers %>%
  # Join workers
  left_join(zn208,
            by = "CD_ZT208") %>%
  st_as_sf()

jobs_sf <- jobs %>%
  # Join jobs
  left_join(zn208,
            by = "CD_ZT208") %>%
  st_as_sf()

# sum(zn$workers_transit) + sum(zn$workers_bike) + sum(zn$workers_car) + sum(zn$workers_walk)
# sum(zn$jobs_transit) + sum(zn$jobs_bike) + sum(zn$jobs_car) + sum(zn$jobs_walk)

# in 'zn' now we have how many people go to work from each zone (workers) and the number of people that arrive to that zone (jobs). By mode. 
```

Then add the number of workers and jobs from each ZN to each trip:
```{r}
#add the number of jobs and workers to the od_ft_tt matrix
# OD <- OD_v_HW %>% merge(zn %>% dplyr::select(ZT1259, workers_transit,workers_car,workers_bike,workers_walk) %>% st_drop_geometry(),
#                         by.x = "VORIZT1259", by.y="ZT1259", all.x = TRUE)
# 
# OD <- OD %>% merge(zn %>% dplyr::select(ZT1259, jobs_transit,jobs_car,jobs_bike,jobs_walk) %>% st_drop_geometry(),
#                    by.x = "VDESZT1259", by.y="ZT1259", all.x = TRUE)
# 
# OD <- OD %>% 
#   mutate(workers_transit = ifelse(is.na(workers_transit), 0, workers_transit),
#          workers_car = ifelse(is.na(workers_car), 0, workers_car),
#          workers_bike = ifelse(is.na(workers_bike), 0, workers_bike),
#          workers_walk = ifelse(is.na(workers_walk), 0, workers_walk),
#          jobs_car = ifelse(is.na(jobs_car), 0, jobs_car),
#          jobs_transit = ifelse(is.na(jobs_transit), 0, jobs_transit),
#          jobs_bike = ifelse(is.na(jobs_bike), 0, jobs_bike),
#          jobs_walk = ifelse(is.na(jobs_walk), 0, jobs_walk))
```

Now reshape the data, each row will represent an any origin to to 1 destination (i.e., destination row is unique). We will average the travel times, by mode, and then use this average travel time to find the 'f' (impedance value for travel for each mode). Hint: this is why we needed to find the impedance function in the first place! The functions represent the cost of travel for each mode based on the travel time for a trip, since we are averaging together the travel time for each mode from 
```{r}
# #consolidate trips so each trip is unique. workers = jobs.
# OD_test <- OD %>%
#   group_by(VORIZT1259,VDESZT1259) %>%
#   summarise(trips_transit = sum(trips_transit),
#             trips_car_motor = sum(trips_car_motor),
#             trips_bike = sum(trips_bike),
#             trips_walk = sum(trips_walk),
#             workers_transit = mean(workers_transit), #workers_ and jobs_ values are retained from the ZN object - so they are the same value for each OD pair thus we use mean() here. 
#             workers_car = mean(workers_car),
#             workers_bike = mean(workers_bike),
#             workers_walk = mean(workers_walk),
#             jobs_transit = mean(jobs_transit),
#             jobs_car = mean(jobs_car),
#             jobs_bike = mean(jobs_bike),
#             jobs_walk = mean(jobs_walk)) %>% ungroup()
# 
# OD_test <- OD_test %>% mutate(
#             tt_transit = ifelse(trips_transit != 0, mean(TIEMPO_VIAJES, na.rm=T), NA), #time is averaged for trips from the same origin to destination + same mode - there likely is variation between trips as these come from the survey (e.g., trips taken at different time of day so they are of different length)
#             tt_car = ifelse(trips_car_motor != 0, mean(TIEMPO_VIAJES, na.rm=T), NA), #NOTE: CHECK!!
#             tt_bike = ifelse(trips_bike != 0, mean(TIEMPO_VIAJES, na.rm=T), NA),
#             tt_walk = ifelse(trips_walk != 0, mean(TIEMPO_VIAJES, na.rm=T), NA))


```

```{r}
# OD_test1 <- OD %>%
#   group_by(VORIZT1259,VDESZT1259) %>%
#   summarise(trips_transit = sum(trips_transit),
#             trips_car_motor = sum(trips_car_motor),
#             trips_bike = sum(trips_bike),
#             trips_walk = sum(trips_walk),
#             workers_transit = mean(workers_transit), #workers_ and jobs_ values are retained from the ZN object - so they are the same value for each OD pair thus we use mean() here.
#             workers_car = mean(workers_car),
#             workers_bike = mean(workers_bike),
#             workers_walk = mean(workers_walk),
#             jobs_transit = mean(jobs_transit),
#             jobs_car = mean(jobs_car),
#             jobs_bike = mean(jobs_bike),
#             jobs_walk = mean(jobs_walk)) %>% ungroup()

OD <- OD_v_HW %>%
  group_by(VORI_CD_ZT208,
           VDES_CD_ZT208,
           mode) %>%
  summarize(tt = mean(TIEMPO_VIAJES),
            .groups = "drop")

# Check the mean and median travel times by mode
OD %>% 
  group_by(mode) %>% 
  summarize(mtt = mean(tt))
OD %>% 
  group_by(mode) %>% 
  summarize(mtt = median(tt))

# OD_test_transit <- OD %>% filter(trips_transit == 1) %>%
#   group_by(VORIZT1259,VDESZT1259) %>%
#   summarise(tt_transit = mean(TIEMPO_VIAJES, na.rm=T)) %>% ungroup()
# 
# OD_test_car <- OD %>% filter(trips_car_motor == 1) %>%
#   group_by(VORIZT1259,VDESZT1259) %>%
#   summarise(tt_car = mean(TIEMPO_VIAJES, na.rm=T)) %>% ungroup()
# 
# OD_test_bike <- OD %>% filter(trips_bike == 1) %>%
#   group_by(VORIZT1259,VDESZT1259) %>%
#   summarise(tt_bike = mean(TIEMPO_VIAJES)) %>% ungroup()
# 
# OD_test_walk <- OD %>% filter(trips_walk == 1) %>%
#   group_by(VORIZT1259,VDESZT1259) %>%
#   summarise(tt_walk = mean(TIEMPO_VIAJES)) %>% ungroup()
# 
# OD_test <- OD_test1 %>% merge(OD_test_transit, by=c("VORIZT1259","VDESZT1259"), all=T)
# OD_test <- OD_test %>% merge(OD_test_car, by=c("VORIZT1259","VDESZT1259"), all=T)
# OD_test <- OD_test %>% merge(OD_test_bike, by=c("VORIZT1259","VDESZT1259"), all=T)
# OD_test <- OD_test %>% merge(OD_test_walk, by=c("VORIZT1259","VDESZT1259"), all=T)
# 
# #check, should add up to the origin number of trips 27795 - perfect!
# sum(OD$trips_transit) + sum(OD$trips_car_motor) + sum(OD$trips_bike) + sum(OD$trips_walk)
# sum(OD_test$trips_transit) + sum(OD_test$trips_car_motor) + sum(OD_test$trips_bike) + sum(OD_test$trips_walk)
```

<!--

Check a sample OD pair:
```{r}
OD_test %>% filter(VORIZT1259 == "004-001" & VDESZT1259 == "004-001")
OD %>% filter(VORIZT1259 == "004-001" & VDESZT1259 == "004-001" & trips_car_motor == "1" )
```
Good the averages make sense.
-->

Join workers and jobs to OD table:
```{r}
OD_2 <- OD %>%
  left_join(workers,
            by = c("VORI_CD_ZT208" = "CD_ZT208", "mode"))

OD_2 <- OD_2 %>%
  left_join(jobs,
            by = c("VDES_CD_ZT208" = "CD_ZT208"))
```


Now estimate f value using these averaged travel times:
```{r, echo=FALSE, warning=FALSE, message=FALSE}
#dgamma is the density plot for gamma function and dlnorm is the desntiy plot for the lognormal function; adding values as "f" our impedance function
# OD_test <- OD_test %>%
#   mutate(f_car = dgamma(tt_car, HW_car_motor_gamma$estimate["shape"], HW_car_motor_gamma$estimate["rate"]),
#          f_car = ifelse(is.na(f_car), 0, f_car),
#          f_transit = dlnorm(tt_transit, HW_transit_lnorm$estimate["meanlog"], HW_transit_lnorm$estimate["sdlog"]),
#          f_transit = ifelse(is.na(f_transit), 0, f_transit),
#          f_bike = dlnorm(tt_bike, HW_bike_lnorm$estimate["meanlog"], HW_bike_lnorm$estimate["sdlog"]),
#          f_bike = ifelse(is.na(f_bike), 0, f_bike),
#          f_walk = dlnorm(tt_walk, HW_walk_lnorm$estimate["meanlog"], HW_walk_lnorm$estimate["sdlog"]),
#          f_walk = ifelse(is.na(f_walk), 0, f_walk))

OD_2 <- OD_2 %>%
  mutate(f = case_when(mode == "transit" ~ dgamma(tt,
                                                  HW_transit_lnorm$estimate["shape"], 
                                                  HW_transit_lnorm$estimate["rate"]),
                       mode == "car/motor" ~ dgamma(tt,
                                                    HW_car_motor_gamma$estimate["shape"],
                                                    HW_car_motor_gamma$estimate["rate"]),
                       mode == "bike" ~ dlnorm(tt,
                                               HW_bike_lnorm$estimate["meanlog"],
                                               HW_bike_lnorm$estimate["sdlog"]),
                       mode == "walk" ~ dlogis(tt, 
                                               HW_walk_lnorm$estimate["location"], 
                                               HW_walk_lnorm$estimate["scale"])))
```


## Spatial availability

Calculate spatial availabilty:
```{r}
OD_SA <- OD_2 %>%
  mutate(catch = 1) %>%
  mutate(SA_ij = sp_avail(., 
                          o_id = VORI_CD_ZT208,
                          d_id = VDES_CD_ZT208,
                          pop = workers,
                          opp = jobs,
                          r = catch,
                          f = f))
```

Check that the totals are maintained:
```{r}
sum(OD_SA$SA_ij, na.rm = T)
sum(jobs$jobs)
```

Spatial availability by mode:
```{r}
OD_SA %>%
  group_by(mode) %>%
  summarize(V_m = sum(SA_ij))
```

Spatial availability by origin (with check):
```{r}
SA_i <- OD_SA %>%
  group_by(VORI_CD_ZT208) %>%
  summarize(V_i = sum(SA_ij))

summary(SA_i)
sum(SA_i$V_i)
```

Spatial availability by origin/mode (with check):
```{r}
SA_im <- OD_SA %>%
  group_by(VORI_CD_ZT208, 
           mode) %>%
  summarize(V_im = sum(SA_ij),
            .groups = "drop")

summary(SA_im)
sum(SA_im$V_im)
```

Calculate worker population by zone of origin (with check):
```{r}
population <- workers %>%
  group_by(CD_ZT208) %>%
  summarize(population = sum(workers))

sum(population$population)
```


Join zonal worker population (with checks):
```{r}
SA_i <- SA_i %>%
  left_join(population,
            by = c("VORI_CD_ZT208" = "CD_ZT208"))
sum(SA_i$V_i)

SA_im <- SA_im %>%
  left_join(population,
            by = c("VORI_CD_ZT208" = "CD_ZT208"))
sum(SA_im$V_im)
```

Calculate availability per capita:
```{r}
SA_i <- SA_i %>%
  mutate(v_i = V_i/population)

summary(SA_i)

SA_im <- SA_im %>%
  mutate(v_im = V_im/population)

summary(SA_im)
```

Join geometry of zones to SA:
```{r}
SA_i <- SA_i %>%
  left_join(zn208 %>%
              dplyr::select(CD_ZT208),
            by =c("VORI_CD_ZT208" = "CD_ZT208")) %>%
  st_as_sf()

SA_im <- SA_im %>%
  left_join(zn208 %>%
              dplyr::select(CD_ZT208),
            by = c("VORI_CD_ZT208" = "CD_ZT208")) %>%
  st_as_sf()
```

Preliminaries to plotting:

Figure out which CD_ZT208 correspond to Madrid - we see that CD_ZT208 1 through 59 do so.

```{r}
t <- zn_u %>% dplyr::select(CD_ZT208, Municipality) %>% group_by(CD_ZT208,Municipality) %>% summarize() %>% filter(Municipality == "Madrid")
t
```

```{r create-bounding-boxes}
zn208 <- zn208 %>% mutate(MM = ifelse(str_starts(ZT208,"Madrid"), 1, 0)) %>% filter(MM == 1)

#create the bounding box for the Toronto region + a little extra
bbox_new1 <- st_bbox(zn208 %>%filter(MM == 1)) # current bounding box

xrange <- bbox_new1$xmax - bbox_new1$xmin # range of x values
yrange <- bbox_new1$ymax - bbox_new1$ymin # range of y values

bbox_new1[1] <- bbox_new1[1] - (0.0 * xrange) # xmin - left
bbox_new1[3] <- bbox_new1[3] + (0.0 * xrange) # xmax - right
bbox_new1[2] <- bbox_new1[2] - (0.0 * yrange) # ymin - bottom
bbox_new1[4] <- bbox_new1[4] + (0.0 * yrange) # ymax - top

bbox_Madrid_muni <- bbox_new1 %>%  # take the bounding box ...
  st_as_sfc()

sf::sf_use_s2(FALSE) #this terns off the spherical geometry component in the st_union() function - this assumes the sf is just planar. Thats' fine for our purposes
Madrid_muni_border <- zn208 %>%
  filter(MM == 1) %>%
  st_union()
```

Plot V (spatial availability) by origin:
```{r}
ggplot() +
  geom_sf(data = SA_i,
          aes(fill = V_i),
          color = NA) +
  scale_fill_distiller(palette = "YlGn", #legend scale bar
                       name = expression(v["i"]),
                       na.value = "grey90",
                       direction = 1,
                       trans = "log",
                       breaks=c(0, 10, 100, 1000, 10000))+
  geom_sf(data = Madrid_muni_border, # border for Madrid muni
          colour=alpha("black",1), 
          size = 0.5, 
          fill=NA, 
          show.legend = "polygon") +
  annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
                         height = unit(0.8, "cm"), 
                         width = unit(0.8, "cm"),
                         style = north_arrow_orienteering(line_width = 0.25,
                                                          line_col = "dimgrey", 
                                                          fill = c("white","dimgrey"))) +
  annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
                   height = unit(0.15, "cm")) +
  theme_void() +
  theme(legend.position = c(1.10, 0.25), 
        plot.margin = margin(t = 0, r = 0, b = 0, l = -80)) # positing legend and clipping out white space
```

Plot v (spatial availability per capita) by origin:
```{r}
ggplot() +
  geom_sf(data = SA_i,
          aes(fill = v_i),
          color = NA) +
  scale_fill_gradient2(name = expression(v["i"]),
                       midpoint = 1,
                       na.value = "grey90")+
  geom_sf(data = Madrid_muni_border, # border for Madrid muni
          colour=alpha("black",1), 
          size = 0.5, 
          fill=NA, 
          show.legend = "polygon") +
  annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
                         height = unit(0.8, "cm"), 
                         width = unit(0.8, "cm"),
                         style = north_arrow_orienteering(line_width = 0.25,
                                                          line_col = "dimgrey", 
                                                          fill = c("white","dimgrey"))) +
  annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
                   height = unit(0.15, "cm")) +
  theme_void() +
  theme(legend.position = c(1.10, 0.25), 
        plot.margin = margin(t = 0, r = 0, b = 0, l = -80)) # positing legend and clipping out white space
```

Plot V (spatial availability) by origin-mode:
```{r}
ggplot() +
  geom_sf(data = SA_im,
          aes(fill = V_im),
          color = NA) +
  scale_fill_distiller(palette = "YlGn", #legend scale bar
                       name = expression(v["i"]),
                       na.value = "grey90",
                       direction = 1,
                       trans = "log",
                       breaks=c(0, 10, 100, 1000, 10000))+
  geom_sf(data = Madrid_muni_border, # border for Madrid muni
          colour=alpha("black",1), 
          size = 0.5, 
          fill=NA, 
          show.legend = "polygon") +
  annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
                         height = unit(0.8, "cm"), 
                         width = unit(0.8, "cm"),
                         style = north_arrow_orienteering(line_width = 0.25,
                                                          line_col = "dimgrey", 
                                                          fill = c("white","dimgrey"))) +
  annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
                   height = unit(0.15, "cm")) +
  theme_void() +
  theme(legend.position = c(1.10, 0.25), 
        plot.margin = margin(t = 0, r = 0, b = 0, l = -80)) + # positing legend and clipping out white space
  facet_wrap(~mode, nrow = 2)
```

Plot v (spatial availability per capita) by origin:
```{r}
ggplot() +
  geom_sf(data = SA_im,
          aes(fill = v_im),
          color = NA) +
  scale_fill_gradient2(name = expression(v["i"]),
                       midpoint = 1,
                       na.value = "grey90")+
  geom_sf(data = Madrid_muni_border, # border for Madrid muni
          colour=alpha("black",1), 
          size = 0.5, 
          fill=NA, 
          show.legend = "polygon") +
  annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
                         height = unit(0.8, "cm"), 
                         width = unit(0.8, "cm"),
                         style = north_arrow_orienteering(line_width = 0.25,
                                                          line_col = "dimgrey", 
                                                          fill = c("white","dimgrey"))) +
  annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
                   height = unit(0.15, "cm")) +
  theme_void() +
  theme(legend.position = c(1.10, 0.25), 
        plot.margin = margin(t = 0, r = 0, b = 0, l = -80)) + # positing legend and clipping out white space
  facet_wrap(~mode, nrow = 2)
```

The previous attempts at calculating spatial availability is commented out and included in the end of the document. There were three different approaches, and the approach reflective above is the 3rd approach tested. The first approach can be used in the case of time windows, but the 2nd and 3rd are similar just the 3rd approach is more conceptually easy to understand and code.

# C) Exploring mode shifting, first an optimistic scenario - no cars (all transit) going into madrid municipality

Let's test out a scenario - all car trips going into madrid municipality are now transit trips. How will this impact the SA profile? We will using the 2nd method (calculating SA within all modes).

<!-- AS finished here May 31, am stuck on how to shift car trips to transit (in a way that's flexible and will allow us to easily toggle the modal shift scenarios (i.e., instead of 100% transit, maybe 80%/10/10 transit/bike/walk)) --> 

First, let's re-assign to-madrid muni car trips to transit trips:
```{r}
Madrid_muni <- zn208 %>% filter(MM == 1) 


# OD <- OD_v_HW %>%
#   group_by(VORI_CD_ZT208,
#            VDES_CD_ZT208,
#            mode) %>%
#   summarize(tt = mean(TIEMPO_VIAJES),
#             .groups = "drop")


OD_v_HW_VDES_Mad <- OD_v_HW %>% filter(VDES_Municipality == "Madrid") %>%
  group_by(VORI_CD_ZT208, VDES_CD_ZT208, mode) %>% 
  summarize(TIEMPO_VIAJES = mean(TIEMPO_VIAJES))



OD_v_HW_VDES_Mad %>% mutate(tt = ifelse(mode == "car", ))

OD_v_HW_optimistic1 %>% mutate(TIEMPO_VIAJES_opt = ifelse(mode="car" & MM == 1, NA, ))

OD_v_HW_optimistic1 %>% group_by(mode) %>% summarize(car = mean())

  mutate(TIEMPO_VIAJES_opt = ifelse(mode = "car", ))
```


```{r}
#reassigning car trips to transit trips (i.e., a 100% shift to transit from car)
OD_v_HW_optimistic1 <- OD_v_HW_optimistic  %>% filter(MM == 1) %>% #only CAR trips to Madrid
  mutate(trips_transit = sum(trips_transit,trips_car_motor, na.rm = T), #only trips 
         trips_car_motor = 0) #16627 ODs are making trips INTO muni, this is 59% of all OD pairs

OD_v_HW_optimistic2 <- OD_v_HW_optimistic  %>% filter(is.na(MM))

OD_v_HW_optimistic <- rbind(OD_v_HW_optimistic1,OD_v_HW_optimistic2,OD_v_HW_optimistic2)

workers <- OD_v_HW_optimistic %>%
  group_by(VORIZT1259) %>%
  summarize(workers_transit = sum(trips_transit),
            workers_car = sum(trips_car_motor),
            workers_bike = sum(trips_bike),
            workers_walk = sum(trips_walk),
            .groups = "drop") %>%
  transmute(ZT1259 = VORIZT1259,
            workers_transit,
            workers_car,
            workers_bike,
            workers_walk)

jobs <- OD_v_HW_optimistic %>%
  group_by(VDESZT1259) %>%
  summarize(jobs_transit = sum(trips_transit),
            jobs_car = sum(trips_car_motor),
            jobs_bike = sum(trips_bike),
            jobs_walk = sum(trips_walk),
            .groups = "drop") %>%
  transmute(ZT1259 = VDESZT1259,
            jobs_transit,
            jobs_car,
            jobs_bike,
            jobs_walk)
```

Let's quickly compare how many ODs which have car trips changed to transit had EXISTING transit trips. This may inform what travel time we use.
```{r}
madrid_trips_reassigned <- OD_v_HW_optimistic1 %>%
  group_by(VORIZT1259, VDESZT1259) %>%
  summarise(NEWtrips_transit = sum(trips_transit),
            NEWtrips_car_motor = sum(trips_car_motor))

madrid_trips_original <-OD_v_HW %>%
  group_by(VORIZT1259, VDESZT1259) %>%
  summarise(trips_transit = sum(trips_transit),
            trips_car_motor = sum(trips_car_motor))

madrid_trips_reassigned <- madrid_trips_reassigned %>% merge(madrid_trips_original, by =c("VORIZT1259","VDESZT1259" ))
#all the trip_.y, are the original trips as specified in the travel survey. the trips.x are the assigned trips (moved to transit).

# percentage of transit trips that existed in the original OD pair

countt <- madrid_trips_reassigned %>% mutate(transit_count = ifelse(trips_transit != 0, 1, 0))

sum(countt$transit_count)/nrow(madrid_trips_reassigned)
```

We can see that only ~50% of the OD pairs had a transit trip originally - so we can only borrow transit trip times from thest ODs... we'd have to figure out how to subsitute the remaining 50%. Alternatively - we can figure out any other solution to apply to all mode-shifted trips.

For simplicity, let's continue and  just take the travel time (for car) for these trips and put it on the transit impedance curve.

To continue this process, join the workers and jobs to the ZN simple features object:
```{r}
load("data/zn.RData")

zn <- zn %>%
  # Join workers
  left_join(workers,
            by = "ZT1259") %>%
  # Join jobs
  left_join(jobs,
            by = "ZT1259") %>%
  # Replace NAs with zeros
  mutate(workers_transit = tidyr::replace_na(workers_transit, 0),
         workers_car = tidyr::replace_na(workers_car, 0),
         workers_bike = tidyr::replace_na(workers_bike, 0),
         workers_walk = tidyr::replace_na(workers_walk, 0),
         jobs_transit = tidyr::replace_na(jobs_transit, 0),
         jobs_car = tidyr::replace_na(jobs_car, 0),
         jobs_bike = tidyr::replace_na(jobs_bike, 0),
         jobs_walk = tidyr::replace_na(jobs_walk, 0))
```

add the number of workers and jobs from each zona to each trip:
```{r}
#add the number of jobs and workers to the od_ft_tt matrix
OD_optimistic <- OD_v_HW_optimistic %>% merge(zn %>% dplyr::select(ZT1259, workers_transit,workers_car,workers_bike,workers_walk) %>% st_drop_geometry(),
                                              by.x = "VORIZT1259", by.y="ZT1259", all.x = TRUE)

OD_optimistic <- OD_optimistic %>% merge(zn %>% dplyr::select(ZT1259, jobs_transit,jobs_car,jobs_bike,jobs_walk) %>% st_drop_geometry(),
                                         by.x = "VDESZT1259", by.y="ZT1259", all.x = TRUE)

OD_optimistic <- OD_optimistic %>%
  mutate(workers_transit = ifelse(is.na(workers_transit), 0, workers_transit),
         workers_car = ifelse(is.na(workers_car), 0, workers_car),
         workers_bike = ifelse(is.na(workers_bike), 0, workers_bike),
         workers_walk = ifelse(is.na(workers_walk), 0, workers_walk),
         jobs_car = ifelse(is.na(jobs_car), 0, jobs_car),
         jobs_transit = ifelse(is.na(jobs_transit), 0, jobs_transit),
         jobs_bike = ifelse(is.na(jobs_bike), 0, jobs_bike),
         jobs_walk = ifelse(is.na(jobs_walk), 0, jobs_walk))
```

now reshape the data, each row will represent an any origin to to 1 destination (i.e., destination row is unique). We will average the travel times, by mode, and then use this average travel time to find the 'f' (impedance value for travel for each mode). Note: this is a *KEY* assumption - I'm giving the new transit trips the SAME travel time as they had when traveling by car but I am predicting the travel cost using the impedance curve of TRANSIT instead of CAR - that's the only difference. This is certainly a strange assumption. A solution could be to use the r5r calculated transit travel times but as we saw they don't fit the original data travel times well...
```{r}
#consolidate trips so each trip is unique. workers = jobs.
OD_optimistic <- OD_optimistic %>%
  group_by(VORIZT1259,VDESZT1259) %>%
  summarise(trips_transit = sum(trips_transit),
            trips_car_motor = sum(trips_car_motor),
            trips_bike = sum(trips_bike),
            trips_walk = sum(trips_walk),
            workers_transit = mean(workers_transit),
            # workers_transit = ifelse(is.na(workers_transit), 0, workers_transit),
            workers_car = mean(workers_car),
            # workers_car = ifelse(is.na(workers_car), 0, workers_car),
            workers_bike = mean(workers_bike),
            # workers_bike = ifelse(is.na(workers_bike), 0, workers_bike),
            workers_walk = mean(workers_walk),
            # workers_walk = ifelse(is.na(workers_walk), 0, workers_walk),
            jobs_transit = mean(jobs_transit),
            jobs_car = mean(jobs_car),
            jobs_bike = mean(jobs_bike),
            jobs_walk = mean(jobs_walk),
            # jobs_car = ifelse(is.na(jobs_car), 0, jobs_car),
            # jobs_transit = ifelse(is.na(jobs_transit), 0, jobs_transit),
            # jobs_bike = ifelse(is.na(jobs_bike), 0, jobs_bike),
            # jobs_walk = ifelse(is.na(jobs_walk), 0, jobs_walk),
            tt_transit = ifelse(trips_transit != 0, mean(TIEMPO_VIAJES, na.rm=T), NA),
            tt_car = ifelse(trips_car_motor != 0, mean(TIEMPO_VIAJES, na.rm=T), NA),
            tt_bike = ifelse(trips_bike != 0, mean(TIEMPO_VIAJES, na.rm=T), NA),
            tt_walk = ifelse(trips_walk != 0, mean(TIEMPO_VIAJES, na.rm=T), NA)) %>% ungroup()

```

now estimate f value using these averaged travel times:
```{r, echo=FALSE, warning=FALSE, message=FALSE}
#dgamma is the density plot for gamma function and dlnorm is the desntiy plot for the lognormal function; adding values as "f" our impedance function
OD_optimistic <- OD_optimistic %>%
  mutate(f_car = dgamma(tt_car, HW_car_motor_gamma$estimate["shape"], HW_car_motor_gamma$estimate["rate"]),
         f_car = ifelse(is.na(f_car), 0, f_car),
         f_transit = dlnorm(tt_transit, HW_transit_lnorm$estimate["meanlog"], HW_transit_lnorm$estimate["sdlog"]),
         f_transit = ifelse(is.na(f_transit), 0, f_transit),
         f_bike = dlnorm(tt_bike, HW_bike_lnorm$estimate["meanlog"], HW_bike_lnorm$estimate["sdlog"]),
         f_bike = ifelse(is.na(f_bike), 0, f_bike),
         f_walk = dlnorm(tt_walk, HW_walk_lnorm$estimate["meanlog"], HW_walk_lnorm$estimate["sdlog"]),
         f_walk = ifelse(is.na(f_walk), 0, f_walk))
```

Calculating SA:
```{r}
#add new summed columns
OD_optimistic <- OD_optimistic %>%
  mutate(workers_ = (workers_car+ workers_transit+ workers_bike+ workers_walk),
         workers_ = ifelse(is.na(workers_), 0, workers_),
         jobs_ = (jobs_car + jobs_transit + jobs_bike + jobs_walk),
         jobs_ = ifelse(is.na(jobs_), 0, jobs_),
         f_ = f_car + f_transit + f_bike + f_walk)

#calculate spatial availability
OD_optimistic <- OD_optimistic %>%
  mutate(catch = 1) %>%
  mutate(SA_ij = sp_avail(.,
                          o_id = VORIZT1259,
                          d_id = VDESZT1259,
                          pop = workers_,
                          opp = jobs_,
                          r = catch,
                          f = f_),
         SA_ij = ifelse(is.nan(SA_ij), 0, SA_ij))

#verify that the sum of all jobs is consistent with the number of jobs
sum(OD_optimistic$SA_ij)

#verify that the sum of all jobs is consistent with the number of jobs - from another perspective
sum_jobs <- OD_optimistic %>%
  group_by(VDESZT1259) %>%
  summarise(jobs = mean(jobs_))
sum(sum_jobs$jobs, na.rm = T)
#Perfect it works!
```

Let's aggregate the spatial availability by origin zone:
```{r}
#aggregating spatial availability
MAD_availability <- OD_optimistic %>%
  group_by(VORIZT1259) %>%
  summarize(SA_i3 = sum(SA_ij),
            workers_ = mean(workers_car, na.rm=T) + mean(workers_transit, na.rm=T) + mean(workers_bike, na.rm=T) + mean(workers_walk, na.rm=T),
            avgtt_i = mean(mean(tt_transit) + mean(tt_walk) + mean(tt_car) + mean(tt_bike)),
            avg_f_i = mean(mean(f_transit) + mean(f_walk) + mean(f_car) + mean(f_bike)))

#Merge TO availability calculation to the TAZ sf object created for accessibility above:
zn_test3 <- zn %>% merge(MAD_availability, by.x=c("ZT1259"), by.y=c("VORIZT1259"), all.x=T)
```

Here we plot plot 2 (the original scenario) and plot 3 ( this optimistic scenario)
```{r}
#plot 2
plot_MAD_avail_perworker_3 <- ggplot() +
  geom_sf(data = zn_test3, aes(fill= SA_i3/workers_), color = NA) + #data
  scale_fill_distiller(palette = "RdYlGn", #legend scale bar
                       name = expression(v["i"]),
                       na.value = "grey90",
                       limits = c( round(min(zn_test3$SA_i3/zn_test3$workers_, na.rm=T)),
                                   round(max(zn_test3$SA_i3/zn_test3$workers_, na.rm=T))))+
  geom_sf(data = Madrid_muni_border, # border for Madrid muni
          colour=alpha("dimgrey",1),
          size = 0.5, fill=NA,
          show.legend = "polygon") +
  annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
                         height = unit(0.8, "cm"),
                         width = unit(0.8, "cm"),
                         style = north_arrow_orienteering(line_width = 0.25,
                                                          line_col = "dimgrey",
                                                          fill = c("white","dimgrey"))) +
  annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
                   height = unit(0.15, "cm")) +
  theme_void() +
  theme(legend.position = c(1.10, 0.25),
        plot.margin = margin(t = 0, r = 0, b = 0, l = -80)) # positing legend and clipping out white space


# plot 1 + inset map
plot_MAD_avail_perworker_3 <- ggdraw(plot_MAD_avail_perworker_3) +
  draw_plot({plot_MAD_avail_perworker_3 + coord_sf(xlim = st_coordinates(bbox_Madrid_muni)[c(1,2),1],
                                                   ylim = st_coordinates(bbox_Madrid_muni)[c(2,3),2],
                                                   expand = FALSE) +
      theme(legend.position = "none")},
      x = 0.65, y = 0.50,  # The distance along a (0,1) x-axis (and y axis) to draw the left edge (the bottom edge) of the plot
      width = 0.46, height = 0.46) # The width and height of the plot expressed as proportion of the entire ggdraw object

plot_MAD_avail_perworker_2
plot_MAD_avail_perworker_3
```

As can be seen, the change (visability) is not that dramatic.


The commented out different spatial availability calculation approaches (also done at the ZT1259 resolution instead of ZT208)
<!--

## Comparing 2 spatial availability calculations

```{r}
#calculate spatial availability using the 'sp_avail' function which is defined at the top of the .Rmd
#this is the FIRST way of calculating SA. This calculates SA for each mode seperately (e.g., the competition of car trips only impacts workers who travel by car, etc.) - I believe this method is less realistic.
OD_SA <- OD_test %>%
  mutate(catch = 1) %>%
  mutate(SA_ij_car = sp_avail(., 
                              o_id = VORIZT1259,
                              d_id = VDESZT1259,
                              pop = workers_car,
                              opp = jobs_car,
                              r = catch,
                              f = f_car),
         SA_ij_car = ifelse(is.nan(SA_ij_car), 0, SA_ij_car),
         SA_ij_transit = sp_avail(., 
                                  o_id = VORIZT1259,
                                  d_id = VDESZT1259,
                                  pop = workers_transit,
                                  opp = jobs_transit,
                                  r = catch,
                                  f = f_transit),
         SA_ij_transit = ifelse(is.nan(SA_ij_transit), 0, SA_ij_transit),
         SA_ij_bike = sp_avail(., 
                               o_id = VORIZT1259,
                               d_id = VDESZT1259,
                               pop = workers_bike,
                               opp = jobs_bike,
                               r = catch,
                               f = f_bike),
         SA_ij_bike = ifelse(is.nan(SA_ij_bike), 0, SA_ij_bike),
         SA_ij_walk = sp_avail(., 
                               o_id = VORIZT1259,
                               d_id = VDESZT1259,
                               pop = workers_walk,
                               opp = jobs_walk,
                               r = catch,
                               f = f_walk),
         SA_ij_walk = ifelse(is.nan(SA_ij_walk), 0, SA_ij_walk))

#verify that the sum of all jobs is consistent with the number of jobs
sum(OD_SA$SA_ij_car) + sum(OD_SA$SA_ij_transit) + sum(OD_SA$SA_ij_bike) + sum(OD_SA$SA_ij_walk) 

#verify that the sum of all jobs is consistent with the number of jobs - from another perspective
sum_jobs <- OD_SA %>% 
  group_by(VDESZT1259) %>% 
  summarise(jobs = mean(jobs_transit) + mean(jobs_car)  + mean(jobs_walk) + mean(jobs_bike))
sum(sum_jobs$jobs, na.rm = T)

# same number excellent! there are 27434 jobs total and there are 27795 workers (and subsequently 27795 trips total). The mismatch in numbers arises because we only survey people who's work trip originates in the Madrid region (from home). This means that workers who travel outside of the madrid region still count as a worker (and a trip) + increase 'competition' for the zone.... maybe we don't want this?
```

Let's try calculating SA from a different approach:
```{r}
# Here's SA calculation 2 - instead of separating each mode, I calculate the SA for all modes together so the competition is felt for all workers (not mode specific).  

# here I sum up all the mode specific workers and jobs and impedance values BEFORE calculating SA so we only have 1 resulting SA value for the OD pairs and not 4 (one for each mode) like the other approach.
OD_SA1 <- OD_SA %>%
  mutate(workers_ = (workers_car+ workers_transit+ workers_bike+ workers_walk),
         workers_ = ifelse(is.na(workers_), 0, workers_),
         jobs_ = (jobs_car + jobs_transit + jobs_bike + jobs_walk),
         jobs_ = ifelse(is.na(jobs_), 0, jobs_),
         f_ = f_car + f_transit + f_bike + f_walk) #CHECK: is this still proportional

# as you can see, sometimes an OD row has multiple modes taking that trip - the f_ value sums all modes in that row. 
head(OD_SA1 %>% dplyr::select(f_, f_car, f_transit, f_bike, f_walk), 25)
#*note: summing these all together certainly distorts the travel cost proportional allocation but the correct number of workers (by mode) are multiplied in...so the SA adds up to the number of workers which is a good check. Still not sure what the impact of this is...
head(OD_SA1 %>% dplyr::select(workers_, workers_car, workers_transit, workers_bike, workers_walk), 25)
```

Now calculate SA using this second approach (all workers (not mode specific) compete with each other) and preform some checks:
```{r}
#calculate spatial availability
OD_SA2 <- OD_SA1 %>%
  mutate(catch = 1) %>%
  mutate(SA_ij = sp_avail(., 
                          o_id = VORIZT1259,
                          d_id = VDESZT1259,
                          pop = workers_,
                          opp = jobs_,
                          r = catch,
                          f = f_),
         SA_ij = ifelse(is.nan(SA_ij), 0, SA_ij))

#verify that the sum of all jobs is consistent with the number of jobs
sum(OD_SA2$SA_ij)

#verify that the sum of all jobs is consistent with the number of jobs - from another perspective
sum_jobs <- OD_SA2 %>% 
  group_by(VDESZT1259) %>% 
  summarise(jobs = mean(jobs_))
sum(sum_jobs$jobs, na.rm = T)
#Perfect it works! 
```

Now let's try a third approach. A mix of both examples. imagine:
if 1 origin destination pair has 2 transit trips and 2 car trips, I want to calculate the SA for each trip considering ALL 4 trips (not like in the first attempt when I considered only 2 trips transit, 2 trips car, and then added them together).  So it would look like:

t1 / t1+t2+c1+c2
t2 / t1+t2+c1+c2
c1 / t1+t2+c1+c2
c2 / t1+t2+c1+c2

```{r}
o_id3 <- rep(OD_SA2$VORIZT1259,4)  %>% as.data.frame()
d_id3 <-rep(OD_SA2$VDESZT1259,4)   %>% as.data.frame()

# catch3 <- rep(1, nrow(d_id3)) %>% data.frame() 
catch3 <- stack(OD_SA2[,3:6]) %>% dplyr::select(values) #trips (transit, car, bike, walk)

workers_3 <-  rep(OD_SA2$workers_,4)  %>% as.data.frame()
jobs_3 <- rep(OD_SA2$jobs_,4)  %>% as.data.frame()
# workers_3 <- stack(OD_SA2[,7:10]) %>% dplyr::select(values)
# jobs_3 <- stack(OD_SA2[,11:14]) %>% dplyr::select(values)
#f_3 <- rep(OD_SA2$f_,4)  %>% as.data.frame()
f_3 <- stack(OD_SA2[,c(20,19,21:22)]) %>% dplyr::select(values)

OD_SA3 <- cbind(o_id3, d_id3, catch3, workers_3, jobs_3, f_3) %>% data.frame()
names(OD_SA3)[1:6] <- c("o_id3", "d_id3", "catch3","workers_3", "jobs_3", "f_3")

OD_SA3 <- OD_SA3 %>% mutate(catch3 = ifelse(catch3 != 0, 1, 0)) 
summary(OD_SA3)
```

```{r}
#calculate spatial availability
OD_SA3 <- OD_SA3 %>%
  mutate(catch = 1) %>%
  mutate(SA_ij_3 = sp_avail(.,
                            o_id = o_id3,
                            d_id = d_id3,
                            pop = workers_3, 
                            opp = jobs_3,
                            r = catch,
                            f = f_3))

#verify that the sum of all jobs is consistent with the number of jobs
sum(OD_SA3$SA_ij_3)

```
What's interesting is this third approach yields the same as the second approach. Meaning, when we use to total sum of workers and jobs (across all modes) for each OD pair. repeat the calculation for each mode specific 'f' (i.e., 4 times for each OD pair), and sum up the SA_ij_3 for each OD (each OD has 4 values due to for modes) the resulting value is the same as if the summation of 'f' was done BEFORE the SA calculation. 

These 2 approaches are definitely different than the first approach which only considers the workers and jobs which are taken BY the mode. Effectively, this approach calculates the SA_ij occurring for each mode - independent of the workers / jobs / travel costs of other modes. This 4 SA_ij calculations can also be all summed together and equal back to 27434 (the number of total jobs)
```{r}
OD_SA3 %>% group_by(o_id3, d_id3) %>% summarize(f_3 = sum(f_3),
                                                SA_ij_3 = sum(SA_ij_3))
OD_SA2 %>% group_by(VORIZT1259, VDESZT1259) %>% summarize(f_2 = sum(f_),
                                                          SA_ij2 = sum(SA_ij))
OD_SA2 %>% group_by(VORIZT1259, VDESZT1259) %>% summarize(f_1 = sum(f_car, f_bike, f_walk, f_transit), 
                                                          SA_ij1 = sum(SA_ij_car, SA_ij_bike, SA_ij_transit, SA_ij_walk))

```

# Visually comparing the 2 approaches
Let's aggregate the spatial availability by origin zone for the first 2 methods (calculating SA separately... and calculating 1 SA that combines all modes) and visually compare 
```{r}
#aggregating spatial availability  
MAD_availability <- OD_SA2 %>%
  group_by(VORIZT1259) %>%
  summarize(SA_i2 = sum(SA_ij),
            SA_i1 = sum(SA_ij_car) + sum(SA_ij_bike) + sum(SA_ij_transit) + sum(SA_ij_walk),
            workers_ = mean(workers_car, na.rm=T) + mean(workers_transit, na.rm=T) + mean(workers_bike, na.rm=T) + mean(workers_walk, na.rm=T),
            avgtt_i = mean(mean(tt_transit) + mean(tt_walk) + mean(tt_car) + mean(tt_bike)),
            avg_f_i = mean(mean(f_transit) + mean(f_walk) + mean(f_car) + mean(f_bike))) 

#Merge TO availability calculation to the TAZ sf object created for accessibility above:
zn_test <- zn %>% merge(MAD_availability, by.x=c("ZT1259"), by.y=c("VORIZT1259"), all.x=T) 
```

```{r create-bounding-boxes}
#create the bounding box for the Toronto region + a little extra
bbox_new1 <- st_bbox(zn_test%>%filter(Municipality == "Madrid")) # current bounding box

xrange <- bbox_new1$xmax - bbox_new1$xmin # range of x values
yrange <- bbox_new1$ymax - bbox_new1$ymin # range of y values

bbox_new1[1] <- bbox_new1[1] - (0.0 * xrange) # xmin - left
bbox_new1[3] <- bbox_new1[3] + (0.0 * xrange) # xmax - right
bbox_new1[2] <- bbox_new1[2] - (0.0 * yrange) # ymin - bottom
bbox_new1[4] <- bbox_new1[4] + (0.0 * yrange) # ymax - top

bbox_Madrid_muni <- bbox_new1 %>%  # take the bounding box ...
  st_as_sfc()

Madrid_muni_border <- zn_test%>%filter(Municipality == "Madrid")%>%st_union()
```

plot 1 (SA for each mode calculated seperated and then added together) and plot 2 (SA for all modes calculated together):
```{r}
#plot 1 main plot
plot_MAD_avail1 <- ggplot() +
  geom_sf(data = zn_test, aes(fill= SA_i1), color = NA) + #data
  scale_fill_distiller(palette = "RdYlGn", #legend scale bar
                       name = expression(V["i"]),
                       na.value = "grey90",
                       limits = c( round(min(zn_test$SA_i1, na.rm=T)), round(max(zn_test$SA_i1, na.rm=T)))) +
  geom_sf(data = Madrid_muni_border, # border for Madrid muni
          colour=alpha("dimgrey",1), 
          size = 0.5, fill=NA, 
          show.legend = "polygon") +
  annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
                         height = unit(0.8, "cm"), 
                         width = unit(0.8, "cm"),
                         style = north_arrow_orienteering(line_width = 0.25,
                                                          line_col = "dimgrey", 
                                                          fill = c("white","dimgrey"))) +
  annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
                   height = unit(0.15, "cm")) +
  theme_void() +
  theme(legend.position = c(1.10, 0.25), 
        plot.margin = margin(t = 0, r = 0, b = 0, l = -80)) # positing legend and clipping out white space


# plot 1 + inset map
plot_MAD_avail1 <- ggdraw(plot_MAD_avail1) +
  draw_plot({plot_MAD_avail1 + coord_sf(xlim = st_coordinates(bbox_Madrid_muni)[c(1,2),1],
                                        ylim = st_coordinates(bbox_Madrid_muni)[c(2,3),2],
                                        expand = FALSE) +
      theme(legend.position = "none")},
      x = 0.65, y = 0.50,  # The distance along a (0,1) x-axis (and y axis) to draw the left edge (the bottom edge) of the plot
      width = 0.46, height = 0.46) # The width and height of the plot expressed as proportion of the entire ggdraw object

#plot 2
plot_MAD_avail2 <- ggplot() +
  geom_sf(data = zn_test, aes(fill= SA_i2), color = NA) + #data
  scale_fill_distiller(palette = "RdYlGn", #legend scale bar
                       name = expression(V["i"]),
                       na.value = "grey90",
                       limits = c( round(min(zn_test$SA_i2, na.rm=T)), round(max(zn_test$SA_i2, na.rm=T)))) +
  geom_sf(data = Madrid_muni_border, # border for Madrid muni
          colour=alpha("dimgrey",1), 
          size = 0.5, fill=NA, 
          show.legend = "polygon") +
  annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
                         height = unit(0.8, "cm"), 
                         width = unit(0.8, "cm"),
                         style = north_arrow_orienteering(line_width = 0.25,
                                                          line_col = "dimgrey", 
                                                          fill = c("white","dimgrey"))) +
  annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
                   height = unit(0.15, "cm")) +
  theme_void() +
  theme(legend.position = c(1.10, 0.25), 
        plot.margin = margin(t = 0, r = 0, b = 0, l = -80)) # positing legend and clipping out white space


# plot 1 + inset map
plot_MAD_avail2 <- ggdraw(plot_MAD_avail2) +
  draw_plot({plot_MAD_avail2 + coord_sf(xlim = st_coordinates(bbox_Madrid_muni)[c(1,2),1],
                                        ylim = st_coordinates(bbox_Madrid_muni)[c(2,3),2],
                                        expand = FALSE) +
      theme(legend.position = "none")},
      x = 0.65, y = 0.50,  # The distance along a (0,1) x-axis (and y axis) to draw the left edge (the bottom edge) of the plot
      width = 0.46, height = 0.46) # The width and height of the plot expressed as proportion of the entire ggdraw object

plot_MAD_avail1 # the mode specific SA calculation and then sum them together - approach 1
plot_MAD_avail2 # the f_, worker_, job_, summed together BEFORE SA calculation - approach 2
```
We can normalize it by the number of workers so the numeric value corresponds to available jobs per worker. First plot 1, then plot 2.
```{r}
#plot 1 main plot
plot_MAD_avail_perworker_1 <- ggplot() +
  geom_sf(data = zn_test, aes(fill= SA_i1/workers_), color = NA) + #data
  scale_fill_distiller(palette = "RdYlGn", #legend scale bar
                       name = expression(v["i"]),
                       na.value = "grey90",
                       limits = c( round(min(zn_test$SA_i1/zn_test$workers_, na.rm=T)), 
                                   round(max(zn_test$SA_i1/zn_test$workers_, na.rm=T))))+
  geom_sf(data = Madrid_muni_border, # border for Madrid muni
          colour=alpha("dimgrey",1), 
          size = 0.5, fill=NA, 
          show.legend = "polygon") +
  annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
                         height = unit(0.8, "cm"), 
                         width = unit(0.8, "cm"),
                         style = north_arrow_orienteering(line_width = 0.25,
                                                          line_col = "dimgrey", 
                                                          fill = c("white","dimgrey"))) +
  annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
                   height = unit(0.15, "cm")) +
  theme_void() +
  theme(legend.position = c(1.10, 0.25), 
        plot.margin = margin(t = 0, r = 0, b = 0, l = -80)) # positing legend and clipping out white space


# plot 1 + inset map
plot_MAD_avail_perworker_1 <- ggdraw(plot_MAD_avail_perworker_1) +
  draw_plot({plot_MAD_avail_perworker_1 + coord_sf(xlim = st_coordinates(bbox_Madrid_muni)[c(1,2),1],
                                                   ylim = st_coordinates(bbox_Madrid_muni)[c(2,3),2],
                                                   expand = FALSE) +
      theme(legend.position = "none")},
      x = 0.65, y = 0.50,  # The distance along a (0,1) x-axis (and y axis) to draw the left edge (the bottom edge) of the plot
      width = 0.46, height = 0.46) # The width and height of the plot expressed as proportion of the entire ggdraw object

#plot 2
plot_MAD_avail_perworker_2 <- ggplot() +
  geom_sf(data = zn_test, aes(fill= SA_i2/workers_), color = NA) + #data
  scale_fill_distiller(palette = "RdYlGn", #legend scale bar
                       name = expression(v["i"]),
                       na.value = "grey90",
                       limits = c( round(min(zn_test$SA_i2/zn_test$workers_, na.rm=T)), 
                                   round(max(zn_test$SA_i2/zn_test$workers_, na.rm=T))))+
  geom_sf(data = Madrid_muni_border, # border for Madrid muni
          colour=alpha("dimgrey",1), 
          size = 0.5, fill=NA, 
          show.legend = "polygon") +
  annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
                         height = unit(0.8, "cm"), 
                         width = unit(0.8, "cm"),
                         style = north_arrow_orienteering(line_width = 0.25,
                                                          line_col = "dimgrey", 
                                                          fill = c("white","dimgrey"))) +
  annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
                   height = unit(0.15, "cm")) +
  theme_void() +
  theme(legend.position = c(1.10, 0.25), 
        plot.margin = margin(t = 0, r = 0, b = 0, l = -80)) # positing legend and clipping out white space


# plot 1 + inset map
plot_MAD_avail_perworker_2 <- ggdraw(plot_MAD_avail_perworker_2) +
  draw_plot({plot_MAD_avail_perworker_2 + coord_sf(xlim = st_coordinates(bbox_Madrid_muni)[c(1,2),1],
                                                   ylim = st_coordinates(bbox_Madrid_muni)[c(2,3),2],
                                                   expand = FALSE) +
      theme(legend.position = "none")},
      x = 0.65, y = 0.50,  # The distance along a (0,1) x-axis (and y axis) to draw the left edge (the bottom edge) of the plot
      width = 0.46, height = 0.46) # The width and height of the plot expressed as proportion of the entire ggdraw object

plot_MAD_avail_perworker_1 # the mode specific SA calculation and then sum them together - approach 1
plot_MAD_avail_perworker_2 # the f_, worker_, job_, summed together BEFORE SA calculation - approach 2
```
